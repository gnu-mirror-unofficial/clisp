<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>31.3. Object Pointer Representations</title><link rel="stylesheet" href="impnotes.css" type="text/css"/><link rev="made" href="mailto:clisp-list@sf.net"/><meta name="generator" content="DocBook XSL Stylesheets V1.61.2"/><link rel="home" href="index.html" title="Implementation Notes for GNU CLISP."/><link rel="up" href="gc.html" title="Chapter 31. Overview of CLISP's Garbage Collection"/><link rel="previous" href="lisp-obj-in-c.html" title="31.2. Lisp objects in CLISP"/><link rel="next" href="memory-models.html" title="31.4. Memory Models"/></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">31.3. Object Pointer Representations</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="lisp-obj-in-c.html">Prev</a> </td><th width="60%" align="center">Chapter 31. Overview of <b class="command">CLISP</b>'s Garbage Collection</th><td width="20%" align="right"> <a accesskey="n" href="memory-models.html">Next</a></td></tr></table><hr/></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="typecodes"/>31.3. Object Pointer Representations</h2></div></div><div/></div><p><a href="http://clisp.cons.org" target="_top"><b class="command">CLISP</b></a> implements two ways of representing object pointers.
(An object pointer, <a href="http://www.eskimo.com/~scs/C-faq/top.html" target="_top"><b class="command">C</b></a> type <span class="type">object</span>, contains a
pointer to the memory location of the object, or - for immediate objects
 - all bits of the object itself.)
Both of them have some things in common:
</p><div class="itemizedlist"><ul type="disc"><li>There is a distinction betweem immediate objects
   (<a href="http://www.lisp.org/HyperSpec/Body/syscla_character.html" target="_top"><tt class="classname">CHARACTER</tt></a>s, <a href="http://www.lisp.org/HyperSpec/Body/typ_fixnum.html" target="_top"><tt class="classname">FIXNUM</tt></a>s, <a href="http://www.lisp.org/HyperSpec/Body/typ_short-flo_m_long-float.html" target="_top"><tt class="classname">SHORT-FLOAT</tt></a>s, etc) and
   heap allocated objects.</li><li>All object pointers are typed, i.e. contain a few
   bits of information about the type of the pointed-to object. At a
   minimum, these bits must allow to distinguish immediate and
   heap-allocated objects.</li><li>Not all of the type information is contained in the
   object pointer.  For example, <b class="command">CLOS</b> objects can change their type
   when <a href="http://www.lisp.org/HyperSpec/Body/stagenfun_change-class.html" target="_top"><tt class="function">CHANGE-CLASS</tt></a> is called. To avoid scanning all the heap for
   references when this happens, the class information is stored in the
   heap allocated object, not in the object pointer.</li></ul></div><p>The <a href="typecodes.html" title="31.3. Object Pointer Representations"><strong><tt class="option">NO_TYPECODES</tt></strong></a> object representation has a minimum of type
bits in the object pointer, namely, 2 bits. They allow to distinguish
immediate objects (which have some more type bits), <a href="http://www.lisp.org/HyperSpec/Body/syscla_cons.html" target="_top"><tt class="classname">CONS</tt></a>es (which
have no type bits in the heap, since they occupy just two words in the
heap, with no header), other heap objects (many, from <a href="http://www.lisp.org/HyperSpec/Body/typ_simple-vector.html" target="_top"><tt class="classname">SIMPLE-VECTOR</tt></a>s
to <a href="dffi.html#fptr"><tt class="classname">FFI:FOREIGN-POINTER</tt></a>s), and <span class="type">Subr</span>s. Most object types are
distinguished by looking a the <i class="structfield"><tt>rectype</tt></i> field
in the header of the heap object.</p><p>The <a href="typecodes.html" title="31.3. Object Pointer Representations"><strong><tt class="option">TYPECODES</tt></strong></a> object representation has about two dozen of types
encoded in 6 or 7 bits in the object pointer.
Typically these are the upper 8 bits of a word (on a 32-bit machine) or
the upper 16 bits or 32 bits of a word (on a 64-bit machine).
The particular values of the typecodes allow many common operations to
be performed with a single bit test (e.g. <a href="http://www.lisp.org/HyperSpec/Body/fun_consp.html" target="_top"><tt class="function">CONSP</tt></a> and <a href="http://www.lisp.org/HyperSpec/Body/fun_minuspcm_plusp.html" target="_top"><tt class="function">MINUSP</tt></a> for a
<a href="http://www.lisp.org/HyperSpec/Body/syscla_real.html" target="_top"><tt class="classname">REAL</tt></a> are bit tests) or range check.
However, the <i class="structfield"><tt>rectype</tt></i> field still exists for
many types, because there are many built-in types which do not need a
particularly fast type test.</p><p>Which object representation is chosen is decided at build time
depending on the available preprocessor definitions. You can define
<a href="typecodes.html" title="31.3. Object Pointer Representations"><strong><tt class="option">TYPECODES</tt></strong></a> or <a href="typecodes.html" title="31.3. Object Pointer Representations"><strong><tt class="option">NO_TYPECODES</tt></strong></a> to force one or the other.</p><p>One might expect that <a href="typecodes.html" title="31.3. Object Pointer Representations"><strong><tt class="option">TYPECODES</tt></strong></a> is faster than <a href="typecodes.html" title="31.3. Object Pointer Representations"><strong><tt class="option">NO_TYPECODES</tt></strong></a>
because it does not need to make as many memory accesses. This effect
is, however, hardly measurable in practice (certainly not more than 5%
faster).  Apparently because, first, the situations where the type of an
object is requested but then the object is not looked into are rare.
It is much more common to look into an object, regardless of its type.
Second, due to the existence of data caches in the CPU, accessing a heap
location twice, once for the type test and then immediately afterwards
for the data, is not significantly slower than just accessing the
data.</p><p><a href="typecodes.html" title="31.3. Object Pointer Representations"><strong><tt class="option">TYPECODES</tt></strong></a> is problematic on 32-bit machines, when you want to
use more than 16 MB of memory, because the type bits (at bit 31..24)
interfere with the bits of a heap address. For this reason,
<a href="typecodes.html" title="31.3. Object Pointer Representations"><strong><tt class="option">NO_TYPECODES</tt></strong></a> is the default on 32-bit platforms.</p><p><a href="typecodes.html" title="31.3. Object Pointer Representations"><strong><tt class="option">NO_TYPECODES</tt></strong></a> is problematic on platforms whose object alignment
is less than 4. This affects only the mc680x0 CPU; however, here the
alignment can usually be guaranteed through some <a href="http://gcc.gnu.org/" target="_top"><b class="command">gcc</b></a> options.</p></div><div class="navfooter"><hr/><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="lisp-obj-in-c.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="gc.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="memory-models.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">31.2. Lisp objects in <b class="command">CLISP</b> </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 31.4. Memory Models</td></tr></table></div><div class="custom-footer"><hr width="100%"/><table width="100%"><tr><td align="left"><a href="http://clisp.cons.org"><img src="clisp.png" width="48" height="48" alt="[CLISP home]"/></a></td><td align="center"><a href="http://www.gnu.org"><img src="http://www.gnu.org/graphics/gnubanner.jpg" width="468" height="60" alt="[Come and see what GNU creates for YOU]"/></a></td><td align="right"><a href="http://sourceforge.net"><img src="http://sourceforge.net/sflogo.php?group_id=1355&amp;amp;type=2" width="125" height="37" alt="[SourceForge]"/></a></td></tr></table></div></body></html>
