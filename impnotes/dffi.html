<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<HTML
><HEAD
><TITLE
>Extensions-2.3. The Foreign Function Call Facility</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.76b+
"><LINK
REV="MADE"
HREF="mailto:clisp-list@sf.net"><LINK
REL="HOME"
TITLE="Implementation Notes for GNU CLISP."
HREF="impnotes-top.html"><LINK
REL="UP"
TITLE="Extensions-2: Platform specific Extensions"
HREF="platform.html"><LINK
REL="PREVIOUS"
TITLE="Extensions-2.2. External Modules"
HREF="modules.html"><LINK
REL="NEXT"
TITLE="Extensions-2.4. The Amiga Foreign Function Call Facility"
HREF="affi.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="impnotes.css"></HEAD
><BODY
CLASS="section"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Implementation Notes for <A
HREF="http://www.gnu.org"
TARGET="_top"
>GNU</A
> <A
HREF="http://clisp.cons.org"
TARGET="_top"
><B
CLASS="command"
>CLISP</B
></A
>.: These notes document <A
HREF="http://clisp.cons.org"
TARGET="_top"
><B
CLASS="command"
>CLISP</B
></A
> version 2.31.</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="modules.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 30. Extensions-2: Platform specific Extensions</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="affi.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="section"
><H1
CLASS="section"
><A
NAME="dffi"
></A
>30.3. Extensions-2.3. The Foreign Function Call Facility</H1
><FONT
COLOR="RED"
>Platform dependent: many <A
HREF="http://www.UNIX-systems.org/online.html"
TARGET="_top"
><B
CLASS="emphasis"
>UNIX</B
></A
>, <A
HREF="http://www.willows.com/"
TARGET="_top"
><B
CLASS="emphasis"
>Win32</B
></A
>, <A
HREF="http://www.amiga.org/"
TARGET="_top"
><B
CLASS="emphasis"
>Amiga</B
></A
> platforms
only.</FONT
><P
ALIGN="justify"
>A foreign function description is written as a Lisp file, and when
 compiled it produces a <TT
CLASS="filename"
>#P".c"</TT
> file which is then compiled by the
 <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
> compiler and may be linked together with
 <TT
CLASS="filename"
>lisp.a</TT
>.</P
><P
ALIGN="justify"
>All symbols relating to the foreign function interface are
 exported from the package <A
HREF="dffi.html"
><STRONG
CLASS="package"
><SPAN
CLASS="QUOTE"
>"FFI"</SPAN
></STRONG
></A
>.  To use them,
 <TT
CLASS="sexp"
>(<A
HREF="http://www.lisp.org/HyperSpec/Body/fun_use-package.html"
TARGET="_top"
><TT
CLASS="function"
>USE-PACKAGE</TT
></A
> "FFI")</TT
>.</P
><P
ALIGN="justify"
>Special <A
HREF="dffi.html"
><STRONG
CLASS="package"
><SPAN
CLASS="QUOTE"
>"FFI"</SPAN
></STRONG
></A
> forms may appear anywhere in the Lisp file.</P
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="dffi-overview"
></A
>30.3.1. Overview</H2
><P
ALIGN="justify"
>These are the special <A
HREF="dffi.html"
><STRONG
CLASS="package"
><SPAN
CLASS="QUOTE"
>"FFI"</SPAN
></STRONG
></A
> forms.  We have taken a pragmatic
 approach: the only foreign languages we support for now are <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
>
 and ANSI <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
>.</P
><P
></P
><DIV
CLASS="variablelist"
><P
><B
>special <A
HREF="dffi.html"
><STRONG
CLASS="package"
><SPAN
CLASS="QUOTE"
>"FFI"</SPAN
></STRONG
></A
> forms; <TT
CLASS="replaceable"
><I
>name</I
></TT
> is any Lisp
   <A
HREF="http://www.lisp.org/HyperSpec/Body/syscla_symbol.html"
TARGET="_top"
><TT
CLASS="classname"
>SYMBOL</TT
></A
>; <TT
CLASS="replaceable"
><I
>c-name</I
></TT
> is a <A
HREF="http://www.lisp.org/HyperSpec/Body/syscla_string.html"
TARGET="_top"
><TT
CLASS="classname"
>STRING</TT
></A
>.</B
></P
><DL
><DT
><A
NAME="def-c-type"
></A
><TT
CLASS="sexp"
>(<A
HREF="dffi.html#def-c-type"
><TT
CLASS="function"
>FFI:DEF-C-TYPE</TT
></A
> <TT
CLASS="replaceable"
><I
>name</I
></TT
> <TT
CLASS="replaceable"
><I
>c-type</I
></TT
>)</TT
></DT
><DD
><P
ALIGN="justify"
>This form makes <TT
CLASS="replaceable"
><I
>name</I
></TT
> a shortcut for <TT
CLASS="replaceable"
><I
>c-type</I
></TT
>.
   Note that <TT
CLASS="replaceable"
><I
>c-type</I
></TT
> may already refer to name.
   Forward declarations of types are not possible, however.
</P
></DD
><DT
><A
NAME="def-c-var"
></A
><TT
CLASS="sexp"
>(<A
HREF="dffi.html#def-c-var"
><TT
CLASS="function"
>FFI:DEF-C-VAR</TT
></A
> <TT
CLASS="replaceable"
><I
>name</I
></TT
>
   {<TT
CLASS="replaceable"
><I
>option</I
></TT
>}*)</TT
></DT
><DD
><DIV
CLASS="informaltable"
><A
NAME="def-c-var-bnf"
></A
><P
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="replaceable"
><I
>option</I
></TT
> ::==</TH
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>&nbsp;</TH
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>&nbsp;</TH
></TR
></THEAD
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="sexp"
>(<TT
CLASS="constant"
>:NAME</TT
>
   <TT
CLASS="replaceable"
><I
>c-name</I
></TT
>)</TT
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>|</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="sexp"
>(<TT
CLASS="constant"
>:TYPE</TT
>
  <TT
CLASS="replaceable"
><I
>c-type</I
></TT
>)</TT
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>|</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="sexp"
>(<TT
CLASS="constant"
>:READ-ONLY</TT
>
  <TT
CLASS="replaceable"
><I
>boolean</I
></TT
>)</TT
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>|</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="sexp"
>(:ALLOC
  <A
HREF="dffi.html#allocation"
><TT
CLASS="replaceable"
><I
>ALLOCATION</I
></TT
></A
>)</TT
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>|</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="sexp"
>(:LIBRARY
   <A
HREF="http://www.lisp.org/HyperSpec/Body/syscla_string.html"
TARGET="_top"
><TT
CLASS="classname"
>STRING</TT
></A
>)</TT
></TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
><P
ALIGN="justify"
>This form defines a <A
HREF="dffi.html#dffi-variables"
><TT
CLASS="classname"
>FFI:FOREIGN-VARIABLE</TT
></A
>.  <TT
CLASS="replaceable"
><I
>name</I
></TT
> is the Lisp
 name, a regular Lisp <A
HREF="http://www.lisp.org/HyperSpec/Body/syscla_symbol.html"
TARGET="_top"
><TT
CLASS="classname"
>SYMBOL</TT
></A
>.</P
><P
ALIGN="justify"
>The <TT
CLASS="constant"
>:NAME</TT
> option specifies the name, as seen from <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
>,
 as a string.  If not specified, it is derived from the print name of
 the Lisp name.</P
><P
ALIGN="justify"
>The <TT
CLASS="constant"
>:TYPE</TT
> option specifies the variable's foreign type.</P
><P
ALIGN="justify"
>If the <TT
CLASS="constant"
>:READ-ONLY</TT
> option is specified and non-<A
HREF="http://www.lisp.org/HyperSpec/Body/convar_nil.html"
TARGET="_top"
><TT
CLASS="constant"
>NIL</TT
></A
>,
 it will be impossible to change the variable's value from within Lisp
 (using <A
HREF="http://www.lisp.org/HyperSpec/Body/spefor_setq.html"
TARGET="_top"
><TT
CLASS="function"
>SETQ</TT
></A
> or similar).</P
><P
ALIGN="justify"
>The <TT
CLASS="constant"
>:ALLOC</TT
> option can be either <TT
CLASS="constant"
>:NONE</TT
>
 or <TT
CLASS="constant"
>:MALLOC-FREE</TT
> and defaults to <TT
CLASS="constant"
>:NONE</TT
>.  If it is <TT
CLASS="constant"
>:MALLOC-FREE</TT
>,
 any values of type <A
HREF="dffi.html#c-string"
><SPAN
CLASS="type"
>FFI:C-STRING</SPAN
></A
>, <A
HREF="dffi.html#c-ptr"
><SPAN
CLASS="type"
>FFI:C-PTR</SPAN
></A
>, <A
HREF="dffi.html#c-ptr-null"
><SPAN
CLASS="type"
>FFI:C-PTR-NULL</SPAN
></A
>, <A
HREF="dffi.html#c-array-ptr"
><SPAN
CLASS="type"
>FFI:C-ARRAY-PTR</SPAN
></A
>
 within the foreign value are assumed to be pointers to
 <A
HREF="http://www.opengroup.org/onlinepubs/007904975/functions/malloc.html"
TARGET="_top"
><TT
CLASS="function"
>malloc</TT
></A
>-allocated storage, and when <A
HREF="http://www.lisp.org/HyperSpec/Body/spefor_setq.html"
TARGET="_top"
><TT
CLASS="function"
>SETQ</TT
></A
> replaces an old value by a
 new one, the old storage is freed using <A
HREF="http://www.opengroup.org/onlinepubs/007904975/functions/free.html"
TARGET="_top"
><TT
CLASS="function"
>free</TT
></A
> and the new storage
 allocated using <A
HREF="http://www.opengroup.org/onlinepubs/007904975/functions/malloc.html"
TARGET="_top"
><TT
CLASS="function"
>malloc</TT
></A
>.  If it is <TT
CLASS="constant"
>:NONE</TT
>, <A
HREF="http://www.lisp.org/HyperSpec/Body/spefor_setq.html"
TARGET="_top"
><TT
CLASS="function"
>SETQ</TT
></A
> assumes that the
 pointers point to good storage (not <TT
CLASS="constant"
>NULL</TT
>!) and overwrites the old
 values by the new ones.  This is dangerous (just think of overwriting a
 string with a longer one or storing some data in a <TT
CLASS="constant"
>NULL</TT
> pointer...)
 and deprecated.</P
><P
ALIGN="justify"
><TT
CLASS="constant"
>:LIBRARY</TT
> is the (optional) dynamic library
 which contains the variable.</P
></DD
><DT
><A
NAME="def-call-out"
></A
><TT
CLASS="sexp"
>(<A
HREF="dffi.html#def-call-out"
><TT
CLASS="function"
>FFI:DEF-CALL-OUT</TT
></A
>
              <TT
CLASS="replaceable"
><I
>name</I
></TT
> {<TT
CLASS="replaceable"
><I
>option</I
></TT
>}*)</TT
></DT
><DD
><DIV
CLASS="informaltable"
><A
NAME="def-call-out-bnf"
></A
><P
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="replaceable"
><I
>option</I
></TT
> ::==</TH
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>&nbsp;</TH
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>&nbsp;</TH
></TR
></THEAD
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="sexp"
>(<TT
CLASS="constant"
>:NAME</TT
>
   <TT
CLASS="replaceable"
><I
>c-name</I
></TT
>)</TT
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>|</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="sexp"
>(<TT
CLASS="constant"
>:ARGUMENTS</TT
>
   {(<TT
CLASS="replaceable"
><I
>argument</I
></TT
> <TT
CLASS="replaceable"
><I
>c-type</I
></TT
> [<A
HREF="dffi.html#param-mode"
><TT
CLASS="replaceable"
><I
>PARAM-MODE</I
></TT
></A
> [<A
HREF="dffi.html#allocation"
><TT
CLASS="replaceable"
><I
>ALLOCATION</I
></TT
></A
>]])}*)</TT
>
</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>|</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="sexp"
>(<TT
CLASS="constant"
>:RETURN-TYPE</TT
>
   <TT
CLASS="replaceable"
><I
>c-type</I
></TT
> [<A
HREF="dffi.html#allocation"
><TT
CLASS="replaceable"
><I
>ALLOCATION</I
></TT
></A
>])</TT
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>|</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="sexp"
>(<A
HREF="dffi.html#c-flavor"
><TT
CLASS="constant"
>:LANGUAGE</TT
></A
>
   <TT
CLASS="replaceable"
><I
>language</I
></TT
>)</TT
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>|</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="sexp"
>(:BUILT-IN
   <A
HREF="http://www.lisp.org/HyperSpec/Body/typ_boolean.html"
TARGET="_top"
><TT
CLASS="classname"
>BOOLEAN</TT
></A
>)</TT
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>|</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="sexp"
>(:LIBRARY
   <A
HREF="http://www.lisp.org/HyperSpec/Body/syscla_string.html"
TARGET="_top"
><TT
CLASS="classname"
>STRING</TT
></A
>)</TT
></TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
><P
ALIGN="justify"
>This form defines a named call-out function (a foreign function
 called from Lisp: control flow temporarily leaves Lisp).  Any Lisp
 function call to <TT
CLASS="function"
>#'<TT
CLASS="replaceable"
><I
>name</I
></TT
></TT
>
 is redirected to call the <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
> function <TT
CLASS="replaceable"
><I
>c-name</I
></TT
>.
 <TT
CLASS="constant"
>:LIBRARY</TT
> is the (optional) dynamic library which
 contains the function.
 When the function is a <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
> built-in, the full prototype will be
 output (unless suppressed by <A
HREF="dffi.html#ffi-extern-output"
><TT
CLASS="varname"
>FFI:*OUTPUT-C-FUNCTIONS*</TT
></A
>).
</P
></DD
><DT
><A
NAME="def-call-in"
></A
><TT
CLASS="sexp"
>(<A
HREF="dffi.html#def-call-in"
><TT
CLASS="function"
>FFI:DEF-CALL-IN</TT
></A
>
              <TT
CLASS="replaceable"
><I
>name</I
></TT
> {<TT
CLASS="replaceable"
><I
>option</I
></TT
>}*)</TT
></DT
><DD
><DIV
CLASS="informaltable"
><A
NAME="def-call-in-bnf"
></A
><P
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="replaceable"
><I
>option</I
></TT
> ::==</TH
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>&nbsp;</TH
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>&nbsp;</TH
></TR
></THEAD
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="sexp"
>(<TT
CLASS="constant"
>:NAME</TT
>
   <TT
CLASS="replaceable"
><I
>c-name</I
></TT
>)</TT
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>|</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="sexp"
>(<TT
CLASS="constant"
>:ARGUMENTS</TT
>
   {(<TT
CLASS="replaceable"
><I
>argument</I
></TT
> <TT
CLASS="replaceable"
><I
>c-type</I
></TT
> [<A
HREF="dffi.html#param-mode"
><TT
CLASS="replaceable"
><I
>PARAM-MODE</I
></TT
></A
> [<A
HREF="dffi.html#allocation"
><TT
CLASS="replaceable"
><I
>ALLOCATION</I
></TT
></A
>]])}*)</TT
>
</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>|</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="sexp"
>(<TT
CLASS="constant"
>:RETURN-TYPE</TT
>
   <TT
CLASS="replaceable"
><I
>c-type</I
></TT
> [<A
HREF="dffi.html#allocation"
><TT
CLASS="replaceable"
><I
>ALLOCATION</I
></TT
></A
>])</TT
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>|</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="sexp"
>(<A
HREF="dffi.html#c-flavor"
><TT
CLASS="constant"
>:LANGUAGE</TT
></A
>
   <TT
CLASS="replaceable"
><I
>language</I
></TT
>)</TT
></TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
><P
ALIGN="justify"
>This form defines a named call-in function (i.e., a Lisp
 function called from the foreign language: control flow temporary
 enters Lisp).  Any <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
> function call to the <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
> function
 <TT
CLASS="replaceable"
><I
>c-name</I
></TT
> is redirected to call the <A
HREF="http://www.lisp.org"
TARGET="_top"
><B
CLASS="command"
>Common Lisp</B
></A
> function
 <TT
CLASS="function"
>#'<TT
CLASS="replaceable"
><I
>name</I
></TT
></TT
>.</P
></DD
><DT
><A
NAME="def-c-call-out"
></A
><TT
CLASS="sexp"
>(<A
HREF="dffi.html#def-c-call-out"
><TT
CLASS="function"
>FFI:DEF-C-CALL-OUT</TT
></A
>
        <TT
CLASS="replaceable"
><I
>name</I
></TT
> {<TT
CLASS="replaceable"
><I
>option</I
></TT
>}*)</TT
></DT
><DD
><P
ALIGN="justify"
>This is equivalent to <A
HREF="dffi.html#def-call-out"
><TT
CLASS="function"
>FFI:DEF-CALL-OUT</TT
></A
> with
   <A
HREF="dffi.html#c-flavor"
><TT
CLASS="constant"
>:LANGUAGE</TT
></A
> <TT
CLASS="constant"
>:STDC</TT
>.  <I
CLASS="emphasis"
>deprecated</I
>.
   </P
></DD
><DT
><A
NAME="def-c-call-in"
></A
><TT
CLASS="sexp"
>(<A
HREF="dffi.html#def-c-call-in"
><TT
CLASS="function"
>FFI:DEF-C-CALL-IN</TT
></A
>
        <TT
CLASS="replaceable"
><I
>name</I
></TT
> {<TT
CLASS="replaceable"
><I
>option</I
></TT
>}*)</TT
></DT
><DD
><P
ALIGN="justify"
>This is equivalent to <A
HREF="dffi.html#def-call-in"
><TT
CLASS="function"
>FFI:DEF-CALL-IN</TT
></A
> with
   <A
HREF="dffi.html#c-flavor"
><TT
CLASS="constant"
>:LANGUAGE</TT
></A
> <TT
CLASS="constant"
>:STDC</TT
>.  <I
CLASS="emphasis"
>deprecated</I
>.
   </P
></DD
><DT
><A
NAME="def-c-struct"
></A
><TT
CLASS="sexp"
>(<A
HREF="dffi.html#def-c-struct"
><TT
CLASS="function"
>FFI:DEF-C-STRUCT</TT
></A
>
   <TT
CLASS="replaceable"
><I
>name</I
></TT
> (<TT
CLASS="replaceable"
><I
>symbol</I
></TT
> <TT
CLASS="replaceable"
><I
>c-type</I
></TT
>)*)</TT
></DT
><DD
><P
ALIGN="justify"
>This form defines <TT
CLASS="replaceable"
><I
>name</I
></TT
> to be both a
  <A
HREF="http://www.lisp.org/HyperSpec/Body/syscla_structure-class.html"
TARGET="_top"
><TT
CLASS="classname"
>STRUCTURE-CLASS</TT
></A
> and a foreign <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
> type with the given slots.
  <TT
CLASS="replaceable"
><I
>name</I
></TT
> is a <A
HREF="http://www.lisp.org/HyperSpec/Body/syscla_symbol.html"
TARGET="_top"
><TT
CLASS="classname"
>SYMBOL</TT
></A
> (structure name) or a <A
HREF="http://www.lisp.org/HyperSpec/Body/syscla_list.html"
TARGET="_top"
><TT
CLASS="classname"
>LIST</TT
></A
> whose <A
HREF="http://www.lisp.org/HyperSpec/Body/acc_firstcm_s_inthcm_tenth.html"
TARGET="_top"
><TT
CLASS="function"
>FIRST</TT
></A
>
  element is the structure name and the <A
HREF="http://www.lisp.org/HyperSpec/Body/acc_rest.html"
TARGET="_top"
><TT
CLASS="function"
>REST</TT
></A
> is options.
  Two options are supported at this time:
  <P
></P
><DIV
CLASS="variablelist"
><DL
><DT
><A
NAME="def-c-struct-typedef"
></A
><TT
CLASS="constant"
>:TYPEDEF</TT
></DT
><DD
><P
ALIGN="justify"
>means that the name of this structure is a
      <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
> type defined with <TT
CLASS="function"
>typedef</TT
>
      elsewhere.</P
></DD
><DT
><A
NAME="def-c-struct-external"
></A
><TT
CLASS="constant"
>:EXTERNAL</TT
></DT
><DD
><P
ALIGN="justify"
>means that this structure is defined in a
      <TT
CLASS="filename"
>#P".c"</TT
> file that you include with, e.g.,
      <TT
CLASS="sexp"
>(<A
HREF="dffi.html#c-lines"
><TT
CLASS="function"
>FFI:C-LINES</TT
></A
> "#include &#60;filename.h&#62;")</TT
>.
  </P
></DD
></DL
></DIV
>
  These options determine how the struct is written to the <TT
CLASS="filename"
>#P".c"</TT
>.
</P
></DD
><DT
><A
NAME="def-c-enum"
></A
><TT
CLASS="sexp"
>(<A
HREF="dffi.html#def-c-enum"
><TT
CLASS="function"
>FFI:DEF-C-ENUM</TT
></A
>
   <TT
CLASS="replaceable"
><I
>name</I
></TT
> {<TT
CLASS="replaceable"
><I
>symbol</I
></TT
> | (<TT
CLASS="replaceable"
><I
>symbol</I
></TT
> [<TT
CLASS="replaceable"
><I
>value</I
></TT
>])}*)</TT
></DT
><DD
><P
ALIGN="justify"
>This form defines <TT
CLASS="replaceable"
><I
>symbol</I
></TT
>s
  as constants, similarly to the <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
> declaration <SPAN
CLASS="type"
>enum {
  <TT
CLASS="replaceable"
><I
>symbol</I
></TT
> [= <TT
CLASS="replaceable"
><I
>value</I
></TT
>], ... };</SPAN
></P
><P
ALIGN="justify"
>You can use
 <TT
CLASS="sexp"
>(<TT
CLASS="function"
>FFI:ENUM-FROM-VALUE</TT
> <TT
CLASS="replaceable"
><I
>name</I
></TT
>
  <TT
CLASS="replaceable"
><I
>value</I
></TT
>)</TT
> and
 <TT
CLASS="sexp"
>(<TT
CLASS="function"
>FFI:ENUM-TO-VALUE</TT
> <TT
CLASS="replaceable"
><I
>name</I
></TT
>
  <TT
CLASS="replaceable"
><I
>symbol</I
></TT
>)</TT
> to convert between the numeric and symbolic
 representations (of course, the latter function boils down to
 <A
HREF="http://www.lisp.org/HyperSpec/Body/acc_symbol-value.html"
TARGET="_top"
><TT
CLASS="function"
>SYMBOL-VALUE</TT
></A
> plus a check that the <TT
CLASS="replaceable"
><I
>symbol</I
></TT
> is indeed a constant
 defined in the <A
HREF="dffi.html#def-c-enum"
><TT
CLASS="function"
>FFI:DEF-C-ENUM</TT
></A
> <TT
CLASS="replaceable"
><I
>name</I
></TT
>).</P
></DD
><DT
><A
NAME="c-lines"
></A
><TT
CLASS="sexp"
>(<A
HREF="dffi.html#c-lines"
><TT
CLASS="function"
>FFI:C-LINES</TT
></A
>
  <TT
CLASS="replaceable"
><I
>format-string</I
></TT
> {<TT
CLASS="replaceable"
><I
>argument</I
></TT
>}*)</TT
></DT
><DD
><P
ALIGN="justify"
>This form outputs the string <TT
CLASS="sexp"
>(<A
HREF="http://www.lisp.org/HyperSpec/Body/fun_format.html"
TARGET="_top"
><TT
CLASS="function"
>FORMAT</TT
></A
> <A
HREF="http://www.lisp.org/HyperSpec/Body/convar_nil.html"
TARGET="_top"
><TT
CLASS="constant"
>NIL</TT
></A
> <TT
CLASS="replaceable"
><I
>format-string</I
></TT
>
    {<TT
CLASS="replaceable"
><I
>argument</I
></TT
>}*)</TT
> to the <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
> output file.
   This is a rarely needed low-level facility.
 </P
></DD
><DT
><A
NAME="element"
></A
><TT
CLASS="sexp"
>(<A
HREF="dffi.html#element"
><TT
CLASS="function"
>FFI:ELEMENT</TT
></A
>
     <TT
CLASS="replaceable"
><I
>c-place</I
></TT
> <TT
CLASS="replaceable"
><I
>index<SUB
>1</SUB
></I
></TT
> ...
     <TT
CLASS="replaceable"
><I
>index<SUB
>n</SUB
></I
></TT
>)</TT
></DT
><DD
><P
ALIGN="justify"
>Array element: If <TT
CLASS="replaceable"
><I
>c-place</I
></TT
> is of foreign type
  <TT
CLASS="type"
>(<A
HREF="dffi.html#c-array"
><SPAN
CLASS="type"
>FFI:C-ARRAY</SPAN
></A
> <TT
CLASS="replaceable"
><I
>c-type</I
></TT
>
  (<TT
CLASS="replaceable"
><I
>dim<SUB
>1</SUB
></I
></TT
>
  ... <TT
CLASS="replaceable"
><I
>dim<SUB
>n</SUB
></I
></TT
>))</TT
>
  and 0 &#8804; <TT
CLASS="replaceable"
><I
>index<SUB
>1</SUB
></I
></TT
>
  &#60; <TT
CLASS="replaceable"
><I
>dim<SUB
>1</SUB
></I
></TT
>, ..., 0
  &#8804; <TT
CLASS="replaceable"
><I
>index<SUB
>n</SUB
></I
></TT
> &#60;
  <TT
CLASS="replaceable"
><I
>dim<SUB
>n</SUB
></I
></TT
>, this will be
  the <A
HREF="http://www.lisp.org/HyperSpec/Body/glo_p.html#place"
TARGET="_top"
>place</A
> corresponding to <TT
CLASS="sexp"
>(<A
HREF="http://www.lisp.org/HyperSpec/Body/acc_aref.html"
TARGET="_top"
><TT
CLASS="function"
>AREF</TT
></A
>
  <TT
CLASS="replaceable"
><I
>c-place</I
></TT
> <TT
CLASS="replaceable"
><I
>index<SUB
>1</SUB
></I
></TT
>
  ... <TT
CLASS="replaceable"
><I
>index<SUB
>n</SUB
></I
></TT
>)</TT
> or
  <TT
CLASS="varname"
><TT
CLASS="replaceable"
><I
>c-place</I
></TT
>[<TT
CLASS="replaceable"
><I
>index<SUB
>1</SUB
></I
></TT
>]...[<TT
CLASS="replaceable"
><I
>index<SUB
>n</SUB
></I
></TT
>]</TT
>.
  It is a <A
HREF="http://www.lisp.org/HyperSpec/Body/glo_p.html#place"
TARGET="_top"
>place</A
> of type <TT
CLASS="replaceable"
><I
>c-type</I
></TT
>.
  If <TT
CLASS="replaceable"
><I
>c-place</I
></TT
> is of foreign type <TT
CLASS="type"
>(<A
HREF="dffi.html#c-array-max"
><SPAN
CLASS="type"
>FFI:C-ARRAY-MAX</SPAN
></A
>
  <TT
CLASS="replaceable"
><I
>c-type</I
></TT
> <TT
CLASS="replaceable"
><I
>dim</I
></TT
>)</TT
> and 0 &#8804;
  <TT
CLASS="replaceable"
><I
>index</I
></TT
> &#60; <TT
CLASS="replaceable"
><I
>dim</I
></TT
>,
  this will be the <A
HREF="http://www.lisp.org/HyperSpec/Body/glo_p.html#place"
TARGET="_top"
>place</A
> corresponding to <TT
CLASS="sexp"
>(<A
HREF="http://www.lisp.org/HyperSpec/Body/acc_aref.html"
TARGET="_top"
><TT
CLASS="function"
>AREF</TT
></A
>
  <TT
CLASS="replaceable"
><I
>c-place</I
></TT
> <TT
CLASS="replaceable"
><I
>index</I
></TT
>)</TT
> or
  <TT
CLASS="varname"
><TT
CLASS="replaceable"
><I
>c-place</I
></TT
>[<TT
CLASS="replaceable"
><I
>index</I
></TT
>]</TT
>.
  It is a <A
HREF="http://www.lisp.org/HyperSpec/Body/glo_p.html#place"
TARGET="_top"
>place</A
> of type <TT
CLASS="replaceable"
><I
>c-type</I
></TT
>.
</P
></DD
><DT
><A
NAME="deref"
></A
><TT
CLASS="sexp"
>(<A
HREF="dffi.html#deref"
><TT
CLASS="function"
>FFI:DEREF</TT
></A
>
                <TT
CLASS="replaceable"
><I
>c-place</I
></TT
>)</TT
></DT
><DD
><P
ALIGN="justify"
>Dereference pointer: If
  <TT
CLASS="replaceable"
><I
>c-place</I
></TT
> is of foreign type
  <TT
CLASS="type"
>(<A
HREF="dffi.html#c-ptr"
><SPAN
CLASS="type"
>FFI:C-PTR</SPAN
></A
> <TT
CLASS="replaceable"
><I
>c-type</I
></TT
>)</TT
> or
  <TT
CLASS="type"
>(<A
HREF="dffi.html#c-ptr-null"
><SPAN
CLASS="type"
>FFI:C-PTR-NULL</SPAN
></A
> <TT
CLASS="replaceable"
><I
>c-type</I
></TT
>)</TT
>,
  this will be the <A
HREF="http://www.lisp.org/HyperSpec/Body/glo_p.html#place"
TARGET="_top"
>place</A
> the pointer points to.
  It is a <A
HREF="http://www.lisp.org/HyperSpec/Body/glo_p.html#place"
TARGET="_top"
>place</A
> of type <TT
CLASS="replaceable"
><I
>c-type</I
></TT
>.
  For <TT
CLASS="type"
>(<A
HREF="dffi.html#c-ptr-null"
><SPAN
CLASS="type"
>FFI:C-PTR-NULL</SPAN
></A
> <TT
CLASS="replaceable"
><I
>c-type</I
></TT
>)</TT
>,
  the <TT
CLASS="replaceable"
><I
>c-place</I
></TT
> may not be <TT
CLASS="constant"
>NULL</TT
>.
</P
></DD
><DT
><A
NAME="slot"
></A
><TT
CLASS="sexp"
>(<A
HREF="dffi.html#slot"
><TT
CLASS="function"
>FFI:SLOT</TT
></A
>
       <TT
CLASS="replaceable"
><I
>c-place</I
></TT
> <TT
CLASS="replaceable"
><I
>slot-name</I
></TT
>)</TT
></DT
><DD
><P
ALIGN="justify"
>Struct or union component: If <TT
CLASS="replaceable"
><I
>c-place</I
></TT
> is of
  foreign type <TT
CLASS="type"
>(<A
HREF="dffi.html#c-struct"
><SPAN
CLASS="type"
>FFI:C-STRUCT</SPAN
></A
> <TT
CLASS="replaceable"
><I
>class</I
></TT
>
  ... (<TT
CLASS="replaceable"
><I
>slot-name</I
></TT
> <TT
CLASS="replaceable"
><I
>c-type</I
></TT
>) ...)</TT
> or
  of type <TT
CLASS="type"
>(<A
HREF="dffi.html#c-union"
><SPAN
CLASS="type"
>FFI:C-UNION</SPAN
></A
>
  ... (<TT
CLASS="replaceable"
><I
>slot-name</I
></TT
> <TT
CLASS="replaceable"
><I
>c-type</I
></TT
>) ...)</TT
>,
  this will be of type <TT
CLASS="replaceable"
><I
>c-type</I
></TT
>.
  </P
></DD
><DT
><A
NAME="cast"
></A
><TT
CLASS="sexp"
>(<A
HREF="dffi.html#cast"
><TT
CLASS="function"
>FFI:CAST</TT
></A
>
           <TT
CLASS="replaceable"
><I
>c-place</I
></TT
> <TT
CLASS="replaceable"
><I
>c-type</I
></TT
>)</TT
></DT
><DD
><P
ALIGN="justify"
>Type change: A <A
HREF="http://www.lisp.org/HyperSpec/Body/glo_p.html#place"
TARGET="_top"
>place</A
> denoting the same memory
  locations as the original <TT
CLASS="replaceable"
><I
>c-place</I
></TT
>, but of type <TT
CLASS="replaceable"
><I
>c-type</I
></TT
>.
 </P
></DD
><DT
><A
NAME="offset"
></A
><TT
CLASS="sexp"
>(<A
HREF="dffi.html#offset"
><TT
CLASS="function"
>FFI:OFFSET</TT
></A
>
           <TT
CLASS="replaceable"
><I
>c-place</I
></TT
> <TT
CLASS="replaceable"
><I
>offset</I
></TT
> <TT
CLASS="replaceable"
><I
>c-type</I
></TT
>)</TT
></DT
><DD
><P
ALIGN="justify"
>Type change and displacement: return a <A
HREF="http://www.lisp.org/HyperSpec/Body/glo_p.html#place"
TARGET="_top"
>place</A
> denoting
  a memory locations displaced from the original <TT
CLASS="replaceable"
><I
>c-place</I
></TT
> by an
  <TT
CLASS="replaceable"
><I
>offset</I
></TT
> counted in bytes, with type <TT
CLASS="replaceable"
><I
>c-type</I
></TT
>.
  This can be used to resize an array, e.g. of <TT
CLASS="replaceable"
><I
>c-type</I
></TT
>
  <TT
CLASS="type"
>(<A
HREF="dffi.html#c-array"
><SPAN
CLASS="type"
>FFI:C-ARRAY</SPAN
></A
> <SPAN
CLASS="type"
>uint16</SPAN
> <TT
CLASS="replaceable"
><I
>n</I
></TT
>)</TT
>
  via <TT
CLASS="sexp"
>(<A
HREF="dffi.html#offset"
><TT
CLASS="function"
>FFI:OFFSET</TT
></A
> <TT
CLASS="replaceable"
><I
>c-place</I
></TT
> 0
  '(<A
HREF="dffi.html#c-array"
><SPAN
CLASS="type"
>FFI:C-ARRAY</SPAN
></A
> <SPAN
CLASS="type"
>uint16</SPAN
> <TT
CLASS="replaceable"
><I
>k</I
></TT
>))</TT
>.
 </P
></DD
><DT
><A
NAME="c-var-addr"
></A
><TT
CLASS="sexp"
>(<A
HREF="dffi.html#c-var-addr"
><TT
CLASS="function"
>FFI:C-VAR-ADDRESS</TT
></A
>
           <TT
CLASS="replaceable"
><I
>c-place</I
></TT
>)</TT
></DT
><DD
><P
ALIGN="justify"
>Return the address of <TT
CLASS="replaceable"
><I
>c-place</I
></TT
> as a Lisp object of
  type <A
HREF="dffi.html#faddr"
><TT
CLASS="classname"
>FFI:FOREIGN-ADDRESS</TT
></A
>.  This is useful as an argument
  to foreign functions expecting a parameter of <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
> type <A
HREF="dffi.html#c-pointer"
><SPAN
CLASS="type"
>FFI:C-POINTER</SPAN
></A
>.
 </P
></DD
><DT
><A
NAME="c-var-object"
></A
><TT
CLASS="sexp"
>(<A
HREF="dffi.html#c-var-object"
><TT
CLASS="function"
>FFI:C-VAR-OBJECT</TT
></A
>
   <TT
CLASS="replaceable"
><I
>c-place</I
></TT
>)</TT
></DT
><DD
><P
ALIGN="justify"
>Return the <A
HREF="dffi.html#dffi-variables"
><TT
CLASS="classname"
>FFI:FOREIGN-VARIABLE</TT
></A
> object underlying the
   <TT
CLASS="replaceable"
><I
>c-place</I
></TT
>.  This is also an acceptable argument type to a <A
HREF="dffi.html#c-pointer"
><SPAN
CLASS="type"
>FFI:C-POINTER</SPAN
></A
>
   declaration.</P
></DD
><DT
><A
NAME="typeof"
></A
><TT
CLASS="sexp"
>(<A
HREF="dffi.html#typeof"
><TT
CLASS="function"
>FFI:TYPEOF</TT
></A
>
    <TT
CLASS="replaceable"
><I
>c-place</I
></TT
>)</TT
></DT
><DD
><P
ALIGN="justify"
>returns the <TT
CLASS="replaceable"
><I
>c-type</I
></TT
> corresponding to the <TT
CLASS="replaceable"
><I
>c-place</I
></TT
>.
</P
></DD
><DT
><A
NAME="sizeof"
></A
><TT
CLASS="sexp"
>(<A
HREF="dffi.html#sizeof"
><TT
CLASS="function"
>FFI:SIZEOF</TT
></A
> <TT
CLASS="replaceable"
><I
>c-type</I
></TT
>)</TT
><BR><TT
CLASS="sexp"
>(<A
HREF="dffi.html#sizeof"
><TT
CLASS="function"
>FFI:SIZEOF</TT
></A
> <TT
CLASS="replaceable"
><I
>c-place</I
></TT
>)</TT
></DT
><DD
><P
ALIGN="justify"
>The first form returns the size and alignment of a
  <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
> type <TT
CLASS="replaceable"
><I
>c-type</I
></TT
>, measured in bytes.</P
><P
ALIGN="justify"
>The second form returns the size and alignment of the
  <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
> type of <TT
CLASS="replaceable"
><I
>c-place</I
></TT
>, measured in bytes.
  </P
></DD
><DT
><A
NAME="bitsizeof"
></A
><TT
CLASS="sexp"
>(<A
HREF="dffi.html#bitsizeof"
><TT
CLASS="function"
>FFI:BITSIZEOF</TT
></A
> <TT
CLASS="replaceable"
><I
>c-type</I
></TT
>)</TT
><BR><TT
CLASS="sexp"
>(<A
HREF="dffi.html#bitsizeof"
><TT
CLASS="function"
>FFI:BITSIZEOF</TT
></A
> <TT
CLASS="replaceable"
><I
>c-place</I
></TT
>)</TT
></DT
><DD
><P
ALIGN="justify"
>The first form returns the size and alignment of the
  <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
> type <TT
CLASS="replaceable"
><I
>c-type</I
></TT
>, measured in bits.</P
><P
ALIGN="justify"
>The second form returns the size and alignment of the
  <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
> type of <TT
CLASS="replaceable"
><I
>c-place</I
></TT
>, measured in bits.
 </P
></DD
><DT
><A
NAME="fa-null"
></A
><TT
CLASS="sexp"
>(<A
HREF="dffi.html#fa-null"
><TT
CLASS="function"
>FFI:FOREIGN-ADDRESS-NULL</TT
></A
> <TT
CLASS="replaceable"
><I
>foreign-entity</I
></TT
>)</TT
></DT
><DD
><P
ALIGN="justify"
>This predicate returns <A
HREF="http://www.lisp.org/HyperSpec/Body/convar_t.html"
TARGET="_top"
><TT
CLASS="constant"
>T</TT
></A
> if the
  <TT
CLASS="replaceable"
><I
>foreign-entity</I
></TT
> refers to the <TT
CLASS="constant"
>NULL</TT
> address (and thus <TT
CLASS="replaceable"
><I
>foreign-entity</I
></TT
> should
  probably not be passed to most foreign functions).
 </P
></DD
><DT
><A
NAME="faddr-u"
></A
><TT
CLASS="sexp"
>(<A
HREF="dffi.html#faddr-u"
><TT
CLASS="function"
>FFI:FOREIGN-ADDRESS-UNSIGNED</TT
></A
>
   <TT
CLASS="replaceable"
><I
>foreign-entity</I
></TT
>)</TT
><BR><TT
CLASS="sexp"
>(<A
HREF="dffi.html#faddr-u"
><TT
CLASS="function"
>FFI:UNSIGNED-FOREIGN-ADDRESS</TT
></A
>
   <TT
CLASS="replaceable"
><I
>number</I
></TT
>)</TT
></DT
><DD
><P
ALIGN="justify"
><A
HREF="dffi.html#faddr-u"
><TT
CLASS="function"
>FFI:FOREIGN-ADDRESS-UNSIGNED</TT
></A
> returns the <A
HREF="http://www.lisp.org/HyperSpec/Body/syscla_integer.html"
TARGET="_top"
><TT
CLASS="classname"
>INTEGER</TT
></A
>
   address embodied in the Lisp object of type <A
HREF="dffi.html#faddr"
><TT
CLASS="classname"
>FFI:FOREIGN-ADDRESS</TT
></A
>,
   <A
HREF="dffi.html#fptr"
><TT
CLASS="classname"
>FFI:FOREIGN-POINTER</TT
></A
>, <A
HREF="dffi.html#dffi-variables"
><TT
CLASS="classname"
>FFI:FOREIGN-VARIABLE</TT
></A
> or <A
HREF="dffi.html"
><TT
CLASS="classname"
>FFI:FOREIGN-FUNCTION</TT
></A
>.</P
><P
ALIGN="justify"
><A
HREF="dffi.html#faddr-u"
><TT
CLASS="function"
>FFI:UNSIGNED-FOREIGN-ADDRESS</TT
></A
> returns a <A
HREF="dffi.html#faddr"
><TT
CLASS="classname"
>FFI:FOREIGN-ADDRESS</TT
></A
>
   object pointing to the given <A
HREF="http://www.lisp.org/HyperSpec/Body/syscla_integer.html"
TARGET="_top"
><TT
CLASS="classname"
>INTEGER</TT
></A
> address.
</P
></DD
><DT
><A
NAME="faddr"
></A
><TT
CLASS="sexp"
>(<A
HREF="dffi.html#faddr"
><TT
CLASS="function"
>FFI:FOREIGN-ADDRESS</TT
></A
> <TT
CLASS="replaceable"
><I
>foreign-entity</I
></TT
>)</TT
></DT
><DD
><P
ALIGN="justify"
><A
HREF="dffi.html#faddr"
><TT
CLASS="function"
>FFI:FOREIGN-ADDRESS</TT
></A
> is both a type name and a
   selector/constructor function. It is the Lisp object type
   corresponding to a <A
HREF="dffi.html#c-pointer"
><SPAN
CLASS="type"
>FFI:C-POINTER</SPAN
></A
> external type declaration, e.g. a
   call-out function with <TT
CLASS="sexp"
>(<TT
CLASS="constant"
>:RETURN-TYPE</TT
>
    <A
HREF="dffi.html#c-pointer"
><SPAN
CLASS="type"
>FFI:C-POINTER</SPAN
></A
>)</TT
> yields a Lisp object of type
   <A
HREF="dffi.html#faddr"
><TT
CLASS="classname"
>FFI:FOREIGN-ADDRESS</TT
></A
>.</P
><P
ALIGN="justify"
>The function extracts the object of type <A
HREF="dffi.html#faddr"
><TT
CLASS="classname"
>FFI:FOREIGN-ADDRESS</TT
></A
>
   living within any <A
HREF="dffi.html#dffi-variables"
><TT
CLASS="classname"
>FFI:FOREIGN-VARIABLE</TT
></A
> or <A
HREF="dffi.html"
><TT
CLASS="classname"
>FFI:FOREIGN-FUNCTION</TT
></A
> object.
   If the <TT
CLASS="replaceable"
><I
>foreign-entity</I
></TT
> already is a <A
HREF="dffi.html#faddr"
><TT
CLASS="classname"
>FFI:FOREIGN-ADDRESS</TT
></A
>, it returns it.
   If it is a <A
HREF="dffi.html#fptr"
><TT
CLASS="classname"
>FFI:FOREIGN-POINTER</TT
></A
> (e.g. a base foreign library address),
   it encapsulates it into a <A
HREF="dffi.html#faddr"
><TT
CLASS="classname"
>FFI:FOREIGN-ADDRESS</TT
></A
> object, as suitable
   for use with a <A
HREF="dffi.html#c-pointer"
><SPAN
CLASS="type"
>FFI:C-POINTER</SPAN
></A
> external type declaration.
   It does not construct addresses out of <A
HREF="http://www.lisp.org/HyperSpec/Body/syscla_number.html"
TARGET="_top"
><TT
CLASS="classname"
>NUMBER</TT
></A
>s,
   <A
HREF="dffi.html#faddr-u"
><TT
CLASS="function"
>FFI:UNSIGNED-FOREIGN-ADDRESS</TT
></A
> must be used for that purpose.
</P
></DD
><DT
><A
NAME="validp"
></A
><TT
CLASS="sexp"
>(<A
HREF="dffi.html#validp"
><TT
CLASS="function"
>FFI:VALIDP</TT
></A
> <TT
CLASS="replaceable"
><I
>foreign-entity</I
></TT
>)</TT
><BR><TT
CLASS="sexp"
>(<A
HREF="http://www.lisp.org/HyperSpec/Body/mac_setfcm_psetf.html"
TARGET="_top"
><TT
CLASS="function"
>SETF</TT
></A
> (<A
HREF="dffi.html#validp"
><TT
CLASS="function"
>FFI:VALIDP</TT
></A
> <TT
CLASS="replaceable"
><I
>foreign-entity</I
></TT
>)
    <TT
CLASS="replaceable"
><I
>value</I
></TT
>)</TT
></DT
><DD
><P
ALIGN="justify"
>This predicate returns <A
HREF="http://www.lisp.org/HyperSpec/Body/convar_nil.html"
TARGET="_top"
><TT
CLASS="constant"
>NIL</TT
></A
> if the <TT
CLASS="replaceable"
><I
>foreign-entity</I
></TT
>
  (e.g. the Lisp equivalent of a <A
HREF="dffi.html#c-pointer"
><SPAN
CLASS="type"
>FFI:C-POINTER</SPAN
></A
>) refers to a pointer
  which is invalid because it comes from a previous Lisp session.
  It returns <A
HREF="http://www.lisp.org/HyperSpec/Body/convar_t.html"
TARGET="_top"
><TT
CLASS="constant"
>T</TT
></A
> if <TT
CLASS="replaceable"
><I
>foreign-entity</I
></TT
> can be used within the current Lisp process
  (thus it returns <A
HREF="http://www.lisp.org/HyperSpec/Body/convar_t.html"
TARGET="_top"
><TT
CLASS="constant"
>T</TT
></A
> for all non-foreign arguments).</P
><P
ALIGN="justify"
>You can invalidate a foreign object using
  <TT
CLASS="sexp"
>(<A
HREF="http://www.lisp.org/HyperSpec/Body/mac_setfcm_psetf.html"
TARGET="_top"
><TT
CLASS="function"
>SETF</TT
></A
> <A
HREF="dffi.html#validp"
><TT
CLASS="function"
>FFI:VALIDP</TT
></A
>)</TT
>.
  You cannot resurrect a zombie, nor can you kill a non-foreign
  object.</P
></DD
><DT
><A
NAME="fptr"
></A
><TT
CLASS="sexp"
>(<A
HREF="dffi.html#fptr"
><TT
CLASS="function"
>FFI:FOREIGN-POINTER</TT
></A
> <TT
CLASS="replaceable"
><I
>foreign-entity</I
></TT
>)</TT
><BR><TT
CLASS="sexp"
>(<A
HREF="http://www.lisp.org/HyperSpec/Body/mac_setfcm_psetf.html"
TARGET="_top"
><TT
CLASS="function"
>SETF</TT
></A
> (<A
HREF="dffi.html#fptr"
><TT
CLASS="function"
>FFI:FOREIGN-POINTER</TT
></A
> <TT
CLASS="replaceable"
><I
>foreign-entity</I
></TT
>)
   <TT
CLASS="replaceable"
><I
>foreign-pointer</I
></TT
>)</TT
></DT
><DD
><P
ALIGN="justify"
><A
HREF="dffi.html#fptr"
><TT
CLASS="function"
>FFI:FOREIGN-POINTER</TT
></A
> returns the <A
HREF="dffi.html#fptr"
><TT
CLASS="classname"
>FFI:FOREIGN-POINTER</TT
></A
>
   associated with the Lisp object of type <A
HREF="dffi.html#faddr"
><TT
CLASS="classname"
>FFI:FOREIGN-ADDRESS</TT
></A
>,
   <A
HREF="dffi.html#fptr"
><TT
CLASS="classname"
>FFI:FOREIGN-POINTER</TT
></A
>, <A
HREF="dffi.html#dffi-variables"
><TT
CLASS="classname"
>FFI:FOREIGN-VARIABLE</TT
></A
> or <A
HREF="dffi.html"
><TT
CLASS="classname"
>FFI:FOREIGN-FUNCTION</TT
></A
>.</P
><P
ALIGN="justify"
><TT
CLASS="sexp"
>(<A
HREF="http://www.lisp.org/HyperSpec/Body/mac_setfcm_psetf.html"
TARGET="_top"
><TT
CLASS="function"
>SETF</TT
></A
> <A
HREF="dffi.html#fptr"
><TT
CLASS="function"
>FFI:FOREIGN-POINTER</TT
></A
>)</TT
>
   changes the <A
HREF="dffi.html#fptr"
><TT
CLASS="classname"
>FFI:FOREIGN-POINTER</TT
></A
> associated with the Lisp object of
   type <A
HREF="dffi.html#faddr"
><TT
CLASS="classname"
>FFI:FOREIGN-ADDRESS</TT
></A
>, <A
HREF="dffi.html#dffi-variables"
><TT
CLASS="classname"
>FFI:FOREIGN-VARIABLE</TT
></A
> or <A
HREF="dffi.html"
><TT
CLASS="classname"
>FFI:FOREIGN-FUNCTION</TT
></A
> to
   that of the other entity.
   When <TT
CLASS="replaceable"
><I
>foreign-pointer</I
></TT
> is <TT
CLASS="constant"
>:COPY</TT
>, a fresh <A
HREF="dffi.html#fptr"
><TT
CLASS="classname"
>FFI:FOREIGN-POINTER</TT
></A
> is allocated.
   <TT
CLASS="replaceable"
><I
>foreign-entity</I
></TT
> still points to the same object. This is particularly useful
   with <TT
CLASS="sexp"
>(<A
HREF="http://www.lisp.org/HyperSpec/Body/mac_setfcm_psetf.html"
TARGET="_top"
><TT
CLASS="function"
>SETF</TT
></A
> <A
HREF="dffi.html#validp"
><TT
CLASS="function"
>FFI:VALIDP</TT
></A
>)</TT
>.
</P
></DD
><DT
><A
NAME="foreign-stack"
></A
><TT
CLASS="sexp"
>(<A
HREF="dffi.html#foreign-stack"
><TT
CLASS="function"
>FFI:WITH-FOREIGN-OBJECT</TT
></A
> (<TT
CLASS="replaceable"
><I
>variable</I
></TT
> <TT
CLASS="replaceable"
><I
>c-type</I
></TT
>
      [<TT
CLASS="replaceable"
><I
>initarg</I
></TT
>]) <TT
CLASS="replaceable"
><I
>body</I
></TT
>)</TT
><BR><TT
CLASS="sexp"
>(<A
HREF="dffi.html#foreign-stack"
><TT
CLASS="function"
>FFI:WITH-C-VAR</TT
></A
> (<TT
CLASS="replaceable"
><I
>variable</I
></TT
> <TT
CLASS="replaceable"
><I
>c-type</I
></TT
>
      [<TT
CLASS="replaceable"
><I
>initarg</I
></TT
>]) <TT
CLASS="replaceable"
><I
>body</I
></TT
>)</TT
></DT
><DD
><P
ALIGN="justify"
>These forms allocate space on the <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
> execution
  stack, bind respectively a <A
HREF="dffi.html#dffi-variables"
><TT
CLASS="classname"
>FFI:FOREIGN-VARIABLE</TT
></A
> object or
  a local <A
HREF="http://www.lisp.org/HyperSpec/Body/mac_define-symbol-macro.html"
TARGET="_top"
><TT
CLASS="classname"
>SYMBOL-MACRO</TT
></A
> to <TT
CLASS="replaceable"
><I
>variable</I
></TT
> and execute <TT
CLASS="replaceable"
><I
>body</I
></TT
>.</P
><P
ALIGN="justify"
>When <TT
CLASS="replaceable"
><I
>initarg</I
></TT
> is not supplied,
  they allocate space only for <TT
CLASS="sexp"
>(<A
HREF="dffi.html#sizeof"
><TT
CLASS="function"
>FFI:SIZEOF</TT
></A
>
  <TT
CLASS="replaceable"
><I
>c-type</I
></TT
>)</TT
> bytes.  This space is filled with zeroes.  E.g.,
  using a <TT
CLASS="replaceable"
><I
>c-type</I
></TT
> of <A
HREF="dffi.html#c-string"
><SPAN
CLASS="type"
>FFI:C-STRING</SPAN
></A
> or even <TT
CLASS="type"
>(<A
HREF="dffi.html#c-ptr"
><SPAN
CLASS="type"
>FFI:C-PTR</SPAN
></A
>
  (<A
HREF="dffi.html#c-array"
><SPAN
CLASS="type"
>FFI:C-ARRAY</SPAN
></A
> <SPAN
CLASS="type"
>uint8</SPAN
> 32))</TT
> (!) both allocate place
  for a single pointer, initialized to <TT
CLASS="constant"
>NULL</TT
>.</P
><P
ALIGN="justify"
>When <TT
CLASS="replaceable"
><I
>initarg</I
></TT
> is supplied, they
  allocate space for an arbitrarily complex set of structures rooted in
  <TT
CLASS="replaceable"
><I
>c-type</I
></TT
>.  Therefore, <A
HREF="dffi.html#c-array-max"
><SPAN
CLASS="type"
>FFI:C-ARRAY-MAX</SPAN
></A
>, <TT
CLASS="sexp"
>#()</TT
>
  and <TT
CLASS="sexp"
>""</TT
> are your friends for creating a
  pointer to the empty arrays:
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>(with-c-var (v '(c-ptr (c-array-max uint8 32)) #())
  (setf (element (deref v) 0) 127) v)</PRE
></TD
></TR
></TABLE
>
  <TT
CLASS="replaceable"
><I
>c-type</I
></TT
> is evaluated, making creation of variable sized buffers easy:
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>(with-c-var (fv `(c-array uint8 ,(length my-vector)) my-vector)
  (print fv))</PRE
></TD
></TR
></TABLE
>
 </P
></DD
><DT
><A
NAME="foreign-stack-string"
></A
><TT
CLASS="sexp"
>(<A
HREF="dffi.html#foreign-stack-string"
><TT
CLASS="function"
>FFI:WITH-FOREIGN-STRING</TT
></A
>
   (<TT
CLASS="replaceable"
><I
>foreign-address</I
></TT
> <TT
CLASS="replaceable"
><I
>char-count</I
></TT
>
    <TT
CLASS="replaceable"
><I
>byte-count</I
></TT
> <TT
CLASS="replaceable"
><I
>string</I
></TT
>
    <A
HREF="http://www.lisp.org/HyperSpec/Body/sec_3-4-1.html"
TARGET="_top"
><TT
CLASS="literal"
>&#38;KEY</TT
></A
> <TT
CLASS="replaceable"
><I
>encoding</I
></TT
> <TT
CLASS="replaceable"
><I
>null-terminated-p</I
></TT
>
    <TT
CLASS="replaceable"
><I
>start</I
></TT
> <TT
CLASS="replaceable"
><I
>end</I
></TT
>) <A
HREF="http://www.lisp.org/HyperSpec/Body/sec_3-4-4.html"
TARGET="_top"
><TT
CLASS="literal"
>&#38;BODY</TT
></A
> <TT
CLASS="replaceable"
><I
>body</I
></TT
>)</TT
></DT
><DD
><P
ALIGN="justify"
>This forms converts a Lisp <TT
CLASS="replaceable"
><I
>string</I
></TT
> according to
   the <TT
CLASS="replaceable"
><I
>encoding</I
></TT
>, allocating space on the <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
> execution stack.
   <TT
CLASS="replaceable"
><I
>encoding</I
></TT
> can be any <A
HREF="encoding.html"
><TT
CLASS="classname"
>EXT:ENCODING</TT
></A
>, e.g.
   <A
HREF="encoding.html#charset-UTF-16"
><TT
CLASS="constant"
>CHARSET:UTF-16</TT
></A
>
   or <A
HREF="encoding.html#charset-UTF-8"
><TT
CLASS="constant"
>CHARSET:UTF-8</TT
></A
>, circumventing the usual 1:1 limit imposed on
   <A
HREF="encoding.html#foreign-enc"
><TT
CLASS="varname"
>CUSTOM:*FOREIGN-ENCODING*</TT
></A
>.</P
><P
ALIGN="justify"
><TT
CLASS="replaceable"
><I
>body</I
></TT
> is then executed with the three variables <TT
CLASS="replaceable"
><I
>foreign-address</I
></TT
>,
   <TT
CLASS="replaceable"
><I
>char-count</I
></TT
> and
   <TT
CLASS="replaceable"
><I
>byte-count</I
></TT
> respectively bound to an
   untyped <A
HREF="dffi.html#faddr"
><TT
CLASS="classname"
>FFI:FOREIGN-ADDRESS</TT
></A
> (as known from the <A
HREF="dffi.html#c-pointer"
><SPAN
CLASS="type"
>FFI:C-POINTER</SPAN
></A
> foreign
   type specification) pointing to the stack location, the number of
   <A
HREF="http://www.lisp.org/HyperSpec/Body/syscla_character.html"
TARGET="_top"
><TT
CLASS="classname"
>CHARACTER</TT
></A
>s of the Lisp <TT
CLASS="replaceable"
><I
>string</I
></TT
> that were considered and the
   number of <TT
CLASS="type"
>(<A
HREF="http://www.lisp.org/HyperSpec/Body/typ_unsigned-byte.html"
TARGET="_top"
><TT
CLASS="classname"
>UNSIGNED-BYTE</TT
></A
> 8)</TT
> bytes that were allocated for it on the
   <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
> stack.</P
><P
ALIGN="justify"
>When <TT
CLASS="replaceable"
><I
>null-terminated-p</I
></TT
> is true,
   which is the default, a variable number of zero bytes is appended,
   depending on the encoding, e.g. 2 for <A
HREF="encoding.html#charset-UTF-8"
><TT
CLASS="constant"
>CHARSET:UTF-8</TT
></A
>,
   and accounted for in <TT
CLASS="replaceable"
><I
>byte-count</I
></TT
>,
   and <TT
CLASS="replaceable"
><I
>char-count</I
></TT
> is incremented by one.</P
><P
ALIGN="justify"
>The <A
HREF="dffi.html#faddr"
><TT
CLASS="classname"
>FFI:FOREIGN-ADDRESS</TT
></A
> object bound to <TT
CLASS="replaceable"
><I
>foreign-address</I
></TT
> is
   invalidated upon the exit from the form.</P
><P
ALIGN="justify"
>A stupid example (a quite costly interface to <A
HREF="http://www.opengroup.org/onlinepubs/007904975/functions/mblen.html"
TARGET="_top"
><TT
CLASS="function"
>mblen</TT
></A
>):
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>(with-foreign-string (fv elems bytes string
                      :encoding charset:jis... :null-terminated-p nil
                      :end 5)
 (declare (ignore fv elems))
 (format t "This string would take ~D bytes." bytes))</PRE
></TD
></TR
></TABLE
>
</P
></DD
><DT
><A
NAME="c-type-parse"
></A
><TT
CLASS="sexp"
>(<A
HREF="dffi.html#c-type-parse"
><TT
CLASS="function"
>FFI:PARSE-C-TYPE</TT
></A
> <TT
CLASS="replaceable"
><I
>c-type</I
></TT
>)</TT
><BR><TT
CLASS="sexp"
>(<A
HREF="dffi.html#c-type-parse"
><TT
CLASS="function"
>FFI:DEPARSE-C-TYPE</TT
></A
> <TT
CLASS="replaceable"
><I
>c-type-internal</I
></TT
>)</TT
></DT
><DD
><P
ALIGN="justify"
>Convert between the external (<A
HREF="http://www.lisp.org/HyperSpec/Body/syscla_list.html"
TARGET="_top"
><TT
CLASS="classname"
>LIST</TT
></A
>) and internal
   (<A
HREF="http://www.lisp.org/HyperSpec/Body/syscla_vector.html"
TARGET="_top"
><TT
CLASS="classname"
>VECTOR</TT
></A
>) <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
> type representations (used by <A
HREF="http://www.lisp.org/HyperSpec/Body/fun_describe.html"
TARGET="_top"
><TT
CLASS="function"
>DESCRIBE</TT
></A
>).
</P
></DD
><DT
><A
NAME="foreign-heap"
></A
><TT
CLASS="sexp"
>(<A
HREF="dffi.html#foreign-heap"
><TT
CLASS="function"
>FFI:ALLOCATE-SHALLOW</TT
></A
> <TT
CLASS="replaceable"
><I
>c-type</I
></TT
>
   <A
HREF="http://www.lisp.org/HyperSpec/Body/sec_3-4-1.html"
TARGET="_top"
><TT
CLASS="literal"
>&#38;KEY</TT
></A
> <TT
CLASS="constant"
>:COUNT</TT
> <TT
CLASS="constant"
>:READ-ONLY</TT
>)</TT
><BR><TT
CLASS="sexp"
>(<A
HREF="dffi.html#foreign-heap"
><TT
CLASS="function"
>FFI:ALLOCATE-DEEP</TT
></A
> <TT
CLASS="replaceable"
><I
>c-type</I
></TT
> <TT
CLASS="replaceable"
><I
>contents</I
></TT
>
   <A
HREF="http://www.lisp.org/HyperSpec/Body/sec_3-4-1.html"
TARGET="_top"
><TT
CLASS="literal"
>&#38;KEY</TT
></A
> <TT
CLASS="constant"
>:COUNT</TT
> <TT
CLASS="constant"
>:READ-ONLY</TT
>)</TT
><BR><TT
CLASS="sexp"
>(<A
HREF="dffi.html#foreign-heap"
><TT
CLASS="function"
>FFI:FOREIGN-FREE</TT
></A
> <TT
CLASS="replaceable"
><I
>foreign-entity</I
></TT
>
   <A
HREF="http://www.lisp.org/HyperSpec/Body/sec_3-4-1.html"
TARGET="_top"
><TT
CLASS="literal"
>&#38;KEY</TT
></A
> :FULL)</TT
><BR><TT
CLASS="sexp"
>(<A
HREF="dffi.html#foreign-heap"
><TT
CLASS="function"
>FFI:FOREIGN-ALLOCATE</TT
></A
> <TT
CLASS="replaceable"
><I
>c-type-internal</I
></TT
>
   <A
HREF="http://www.lisp.org/HyperSpec/Body/sec_3-4-1.html"
TARGET="_top"
><TT
CLASS="literal"
>&#38;KEY</TT
></A
> :INITIAL-CONTENTS <TT
CLASS="constant"
>:COUNT</TT
> <TT
CLASS="constant"
>:READ-ONLY</TT
>)</TT
></DT
><DD
><P
ALIGN="justify"
>Macro <A
HREF="dffi.html#foreign-heap"
><TT
CLASS="function"
>FFI:ALLOCATE-SHALLOW</TT
></A
> allocates
   <TT
CLASS="sexp"
>(<A
HREF="dffi.html#sizeof"
><TT
CLASS="function"
>FFI:SIZEOF</TT
></A
> <TT
CLASS="replaceable"
><I
>c-type</I
></TT
>)</TT
>
   bytes on the <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
> heap and zeroes them out (like <A
HREF="http://www.opengroup.org/onlinepubs/007904975/functions/calloc.html"
TARGET="_top"
><TT
CLASS="function"
>calloc</TT
></A
>).
   When <TT
CLASS="constant"
>:COUNT</TT
> is supplied, <TT
CLASS="replaceable"
><I
>c-type</I
></TT
> is substituted with
   <TT
CLASS="type"
>(<A
HREF="dffi.html#c-array"
><SPAN
CLASS="type"
>FFI:C-ARRAY</SPAN
></A
> <TT
CLASS="replaceable"
><I
>c-type</I
></TT
> <TT
CLASS="replaceable"
><I
>count</I
></TT
>)</TT
>,
   except when <TT
CLASS="replaceable"
><I
>c-type</I
></TT
> is <A
HREF="http://www.lisp.org/HyperSpec/Body/syscla_character.html"
TARGET="_top"
><TT
CLASS="classname"
>CHARACTER</TT
></A
>, in which case
   <TT
CLASS="type"
>(<A
HREF="dffi.html#c-array-max"
><SPAN
CLASS="type"
>FFI:C-ARRAY-MAX</SPAN
></A
> <A
HREF="http://www.lisp.org/HyperSpec/Body/syscla_character.html"
TARGET="_top"
><TT
CLASS="classname"
>CHARACTER</TT
></A
> <TT
CLASS="replaceable"
><I
>count</I
></TT
>)</TT
>
   is used instead.
   When <TT
CLASS="constant"
>:READ-ONLY</TT
> is supplied, the Lisp side is prevented from modifying the
   memory contents.  This can be used as an indication that some foreign
   side is going to fill this memory (e.g. via <A
HREF="http://www.opengroup.org/onlinepubs/007904975/functions/read.html"
TARGET="_top"
><TT
CLASS="function"
>read</TT
></A
>).</P
><P
ALIGN="justify"
>Returns a <A
HREF="dffi.html#dffi-variables"
><TT
CLASS="classname"
>FFI:FOREIGN-VARIABLE</TT
></A
> object of the actual <TT
CLASS="replaceable"
><I
>c-type</I
></TT
>,
   whose address part points to the newly allocated memory.</P
><P
ALIGN="justify"
><A
HREF="dffi.html#foreign-heap"
><TT
CLASS="function"
>FFI:ALLOCATE-DEEP</TT
></A
> will call <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
> <A
HREF="http://www.opengroup.org/onlinepubs/007904975/functions/malloc.html"
TARGET="_top"
><TT
CLASS="function"
>malloc</TT
></A
> as many times
   as necessary to build a structure on the <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
> heap of the given
   <TT
CLASS="replaceable"
><I
>c-type</I
></TT
>, initialized from the given <TT
CLASS="replaceable"
><I
>contents</I
></TT
>.</P
><P
ALIGN="justify"
>E.g., <TT
CLASS="sexp"
>(<A
HREF="dffi.html#foreign-heap"
><TT
CLASS="function"
>FFI:ALLOCATE-DEEP</TT
></A
> '<A
HREF="dffi.html#c-string"
><SPAN
CLASS="type"
>FFI:C-STRING</SPAN
></A
>
    "ABCDE")</TT
> performs 2 allocations: one for a <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
>
   pointer to a string, another for the contents of that string.
   This would be useful in conjunction with a <SPAN
CLASS="type"
>char**</SPAN
>
   <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
> type declaration.  <TT
CLASS="sexp"
>(<A
HREF="dffi.html#foreign-heap"
><TT
CLASS="function"
>FFI:ALLOCATE-SHALLOW</TT
></A
>
    '<A
HREF="dffi.html#c-string"
><SPAN
CLASS="type"
>FFI:C-STRING</SPAN
></A
>)</TT
> allocates room for a single pointer
   (probably 4 bytes).</P
><P
ALIGN="justify"
><TT
CLASS="sexp"
>(<A
HREF="dffi.html#foreign-heap"
><TT
CLASS="function"
>FFI:ALLOCATE-DEEP</TT
></A
> '<A
HREF="http://www.lisp.org/HyperSpec/Body/syscla_character.html"
TARGET="_top"
><TT
CLASS="classname"
>CHARACTER</TT
></A
>
    "ABCDEF" :count 10)</TT
> allocates and initializes room for the
   type <TT
CLASS="type"
>(<A
HREF="dffi.html#c-array-max"
><SPAN
CLASS="type"
>FFI:C-ARRAY-MAX</SPAN
></A
> <A
HREF="http://www.lisp.org/HyperSpec/Body/syscla_character.html"
TARGET="_top"
><TT
CLASS="classname"
>CHARACTER</TT
></A
> 10)</TT
>,
   corresponding to <SPAN
CLASS="type"
>char*</SPAN
> or, more specifically,
   <SPAN
CLASS="type"
>char[10]</SPAN
> in <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
>.</P
><P
ALIGN="justify"
>Function <A
HREF="dffi.html#foreign-heap"
><TT
CLASS="function"
>FFI:FOREIGN-FREE</TT
></A
> deallocates memory at the address
   held by the given <TT
CLASS="replaceable"
><I
>foreign-entity</I
></TT
>. If <TT
CLASS="constant"
>:FULL</TT
> is supplied
   and the argument is of type <A
HREF="dffi.html#dffi-variables"
><TT
CLASS="classname"
>FFI:FOREIGN-VARIABLE</TT
></A
>, recursively frees
   the whole complex stucture pointed to by this variable.</P
><P
ALIGN="justify"
>If given a <A
HREF="dffi.html"
><TT
CLASS="classname"
>FFI:FOREIGN-FUNCTION</TT
></A
> object that corresponds to a
   <A
HREF="http://clisp.cons.org"
TARGET="_top"
><B
CLASS="command"
>CLISP</B
></A
> callback, deallocates it.  Callbacks are automatically
   created each time you pass a Lisp function via the <A
HREF="dffi.html"
><STRONG
CLASS="package"
><SPAN
CLASS="QUOTE"
>"FFI"</SPAN
></STRONG
></A
>.</P
><P
ALIGN="justify"
>Use <TT
CLASS="sexp"
>(<A
HREF="http://www.lisp.org/HyperSpec/Body/mac_setfcm_psetf.html"
TARGET="_top"
><TT
CLASS="function"
>SETF</TT
></A
> <A
HREF="dffi.html#validp"
><TT
CLASS="function"
>FFI:VALIDP</TT
></A
>)</TT
> to
   disable further references to this address from Lisp.
   This is currently not done automatically.
   If the given pointer is already invalid, <A
HREF="dffi.html#foreign-heap"
><TT
CLASS="function"
>FFI:FOREIGN-FREE</TT
></A
> (currently)
   signals an <A
HREF="http://www.lisp.org/HyperSpec/Body/contyp_error.html"
TARGET="_top"
><TT
CLASS="classname"
>ERROR</TT
></A
>. This may change to make it easier to integrate
   with <A
HREF="final.html"
><TT
CLASS="function"
>EXT:FINALIZE</TT
></A
>.</P
><P
ALIGN="justify"
>Function <A
HREF="dffi.html#foreign-heap"
><TT
CLASS="function"
>FFI:FOREIGN-ALLOCATE</TT
></A
> is a lower-level interface as it
   requires an internal <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
> type descriptor as returned by
   <A
HREF="dffi.html#c-type-parse"
><TT
CLASS="function"
>FFI:PARSE-C-TYPE</TT
></A
>.</P
></DD
><DT
><A
NAME="with-c-place"
></A
><TT
CLASS="sexp"
>(<A
HREF="dffi.html#with-c-place"
><TT
CLASS="function"
>FFI:WITH-C-PLACE</TT
></A
> (<TT
CLASS="replaceable"
><I
>variable</I
></TT
> <TT
CLASS="replaceable"
><I
>foreign-entity</I
></TT
>)
   <TT
CLASS="replaceable"
><I
>body</I
></TT
>)</TT
></DT
><DD
><P
ALIGN="justify"
>Create a <A
HREF="http://www.lisp.org/HyperSpec/Body/glo_p.html#place"
TARGET="_top"
>place</A
> out of the given <A
HREF="dffi.html#dffi-variables"
><TT
CLASS="classname"
>FFI:FOREIGN-VARIABLE</TT
></A
>
  object so operations on places (e.g. <A
HREF="dffi.html#cast"
><TT
CLASS="function"
>FFI:CAST</TT
></A
>, <A
HREF="dffi.html#deref"
><TT
CLASS="function"
>FFI:DEREF</TT
></A
>, <A
HREF="dffi.html#slot"
><TT
CLASS="function"
>FFI:SLOT</TT
></A
> etc.) can
  be used within <TT
CLASS="replaceable"
><I
>body</I
></TT
>.  <A
HREF="dffi.html#foreign-stack"
><TT
CLASS="function"
>FFI:WITH-C-VAR</TT
></A
> appears as a composition of
  <A
HREF="dffi.html#foreign-stack"
><TT
CLASS="function"
>FFI:WITH-FOREIGN-OBJECT</TT
></A
> and <A
HREF="dffi.html#with-c-place"
><TT
CLASS="function"
>FFI:WITH-C-PLACE</TT
></A
>.</P
><P
ALIGN="justify"
>Such a <A
HREF="http://www.lisp.org/HyperSpec/Body/glo_p.html#place"
TARGET="_top"
>place</A
> can be used to access memory referenced by a <TT
CLASS="replaceable"
><I
>foreign-entity</I
></TT
>
  object:
  <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>(setq foo (allocate-deep '(c-array uint8 3) rgb))
(with-c-place (place foo) (element place 0))</PRE
></TD
></TR
></TABLE
>
</P
></DD
><DT
><A
NAME="ffi-extern-output"
></A
><A
HREF="dffi.html#ffi-extern-output"
><TT
CLASS="varname"
>FFI:*OUTPUT-C-FUNCTIONS*</TT
></A
><BR><TT
CLASS="varname"
>FFI:*OUTPUT-C-VARIABLES*</TT
></DT
><DD
><P
ALIGN="justify"
><A
HREF="http://clisp.cons.org"
TARGET="_top"
><B
CLASS="command"
>CLISP</B
></A
> will write the <SPAN
CLASS="type"
>extern</SPAN
>
   declarations for foreign functions (defined with <A
HREF="dffi.html#def-call-out"
><TT
CLASS="function"
>FFI:DEF-CALL-OUT</TT
></A
>) and
   foreign variables (defined with <A
HREF="dffi.html#def-c-var"
><TT
CLASS="function"
>FFI:DEF-C-VAR</TT
></A
>) into the output
   <TT
CLASS="filename"
>#P".c"</TT
> <I
CLASS="emphasis"
>unless</I
> these variables are <A
HREF="http://www.lisp.org/HyperSpec/Body/convar_nil.html"
TARGET="_top"
><TT
CLASS="constant"
>NIL</TT
></A
>.
   They are <A
HREF="http://www.lisp.org/HyperSpec/Body/convar_nil.html"
TARGET="_top"
><TT
CLASS="constant"
>NIL</TT
></A
> by default, so the <SPAN
CLASS="type"
>extern</SPAN
>
   declarations are not <I
CLASS="emphasis"
>not</I
> written; you are encouraged to use
   <A
HREF="dffi.html#c-lines"
><TT
CLASS="function"
>FFI:C-LINES</TT
></A
> to include the appropriate <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
> headers.
   Set these variables to non-<A
HREF="http://www.lisp.org/HyperSpec/Body/convar_nil.html"
TARGET="_top"
><TT
CLASS="constant"
>NIL</TT
></A
> if the headers are not available or
   not usable.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="dffi-types"
></A
>30.3.2. (Foreign) <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
> types</H2
><P
ALIGN="justify"
>Foreign <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
> types are used in the <A
HREF="dffi.html"
><STRONG
CLASS="package"
><SPAN
CLASS="QUOTE"
>"FFI"</SPAN
></STRONG
></A
>.
They are <I
CLASS="emphasis"
>not</I
> regular <A
HREF="http://www.lisp.org"
TARGET="_top"
><B
CLASS="command"
>Common Lisp</B
></A
> types or <B
CLASS="command"
>CLOS</B
> classes.</P
><P
ALIGN="justify"
>A <TT
CLASS="replaceable"
><I
>c-type</I
></TT
> is either a predefined <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
> type or the name of a
 type defined by <A
HREF="dffi.html#def-c-type"
><TT
CLASS="function"
>FFI:DEF-C-TYPE</TT
></A
>.</P
><P
></P
><DIV
CLASS="variablelist"
><P
><B
>the predefined <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
> types (<TT
CLASS="replaceable"
><I
>c-type</I
></TT
>)</B
></P
><DL
><DT
><A
NAME="simple-c-type"
></A
><TT
CLASS="replaceable"
><I
>simple-c-type</I
></TT
></DT
><DD
><P
ALIGN="justify"
>the simple <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
> types
  <DIV
CLASS="informaltable"
><A
NAME="simple-c-type-tab"
></A
><P
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="CENTER"
VALIGN="MIDDLE"
>Lisp name</TH
><TH
ALIGN="CENTER"
VALIGN="MIDDLE"
>Lisp equivalent</TH
><TH
ALIGN="CENTER"
VALIGN="MIDDLE"
><A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
> equivalent</TH
><TH
ALIGN="CENTER"
VALIGN="MIDDLE"
>ILU
 equivalent</TH
><TH
ALIGN="CENTER"
VALIGN="MIDDLE"
>Comment</TH
></TR
></THEAD
><TBODY
><TR
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><A
HREF="http://www.lisp.org/HyperSpec/Body/convar_nil.html"
TARGET="_top"
><TT
CLASS="constant"
>NIL</TT
></A
></TD
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><A
HREF="http://www.lisp.org/HyperSpec/Body/convar_nil.html"
TARGET="_top"
><TT
CLASS="constant"
>NIL</TT
></A
></TD
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><SPAN
CLASS="type"
>void</SPAN
></TD
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
>&nbsp;</TD
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
>as a result type only</TD
></TR
><TR
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><A
HREF="http://www.lisp.org/HyperSpec/Body/typ_boolean.html"
TARGET="_top"
><TT
CLASS="classname"
>BOOLEAN</TT
></A
></TD
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><A
HREF="http://www.lisp.org/HyperSpec/Body/typ_boolean.html"
TARGET="_top"
><TT
CLASS="classname"
>BOOLEAN</TT
></A
></TD
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><SPAN
CLASS="type"
>int</SPAN
></TD
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><SPAN
CLASS="type"
>BOOLEAN</SPAN
></TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><A
HREF="http://www.lisp.org/HyperSpec/Body/syscla_character.html"
TARGET="_top"
><TT
CLASS="classname"
>CHARACTER</TT
></A
></TD
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><A
HREF="http://www.lisp.org/HyperSpec/Body/syscla_character.html"
TARGET="_top"
><TT
CLASS="classname"
>CHARACTER</TT
></A
></TD
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><SPAN
CLASS="type"
>char</SPAN
></TD
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><SPAN
CLASS="type"
>SHORT CHARACTER</SPAN
></TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><SPAN
CLASS="type"
>char</SPAN
></TD
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><A
HREF="http://www.lisp.org/HyperSpec/Body/syscla_integer.html"
TARGET="_top"
><TT
CLASS="classname"
>INTEGER</TT
></A
></TD
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><SPAN
CLASS="type"
>signed char</SPAN
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><SPAN
CLASS="type"
>uchar</SPAN
></TD
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><A
HREF="http://www.lisp.org/HyperSpec/Body/syscla_integer.html"
TARGET="_top"
><TT
CLASS="classname"
>INTEGER</TT
></A
></TD
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><SPAN
CLASS="type"
>unsigned char</SPAN
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><SPAN
CLASS="type"
>short</SPAN
></TD
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><A
HREF="http://www.lisp.org/HyperSpec/Body/syscla_integer.html"
TARGET="_top"
><TT
CLASS="classname"
>INTEGER</TT
></A
></TD
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><SPAN
CLASS="type"
>short</SPAN
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><SPAN
CLASS="type"
>ushort</SPAN
></TD
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><A
HREF="http://www.lisp.org/HyperSpec/Body/syscla_integer.html"
TARGET="_top"
><TT
CLASS="classname"
>INTEGER</TT
></A
></TD
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><SPAN
CLASS="type"
>unsigned short</SPAN
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><SPAN
CLASS="type"
>int</SPAN
></TD
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><A
HREF="http://www.lisp.org/HyperSpec/Body/syscla_integer.html"
TARGET="_top"
><TT
CLASS="classname"
>INTEGER</TT
></A
></TD
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><SPAN
CLASS="type"
>int</SPAN
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><SPAN
CLASS="type"
>uint</SPAN
></TD
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><A
HREF="http://www.lisp.org/HyperSpec/Body/syscla_integer.html"
TARGET="_top"
><TT
CLASS="classname"
>INTEGER</TT
></A
></TD
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><SPAN
CLASS="type"
>unsigned int</SPAN
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><SPAN
CLASS="type"
>long</SPAN
></TD
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><A
HREF="http://www.lisp.org/HyperSpec/Body/syscla_integer.html"
TARGET="_top"
><TT
CLASS="classname"
>INTEGER</TT
></A
></TD
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><SPAN
CLASS="type"
>long</SPAN
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><SPAN
CLASS="type"
>ulong</SPAN
></TD
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><A
HREF="http://www.lisp.org/HyperSpec/Body/syscla_integer.html"
TARGET="_top"
><TT
CLASS="classname"
>INTEGER</TT
></A
></TD
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><SPAN
CLASS="type"
>unsigned long</SPAN
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><SPAN
CLASS="type"
>uint8</SPAN
></TD
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><TT
CLASS="type"
>(<A
HREF="http://www.lisp.org/HyperSpec/Body/typ_unsigned-byte.html"
TARGET="_top"
><TT
CLASS="classname"
>UNSIGNED-BYTE</TT
></A
> 8)</TT
></TD
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><SPAN
CLASS="type"
>uint8</SPAN
></TD
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><SPAN
CLASS="type"
>BYTE</SPAN
></TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><SPAN
CLASS="type"
>sint8</SPAN
></TD
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><TT
CLASS="type"
>(<A
HREF="http://www.lisp.org/HyperSpec/Body/typ_signed-byte.html"
TARGET="_top"
><TT
CLASS="classname"
>SIGNED-BYTE</TT
></A
> 8)</TT
></TD
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><SPAN
CLASS="type"
>sint8</SPAN
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><SPAN
CLASS="type"
>uint16</SPAN
></TD
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><TT
CLASS="type"
>(<A
HREF="http://www.lisp.org/HyperSpec/Body/typ_unsigned-byte.html"
TARGET="_top"
><TT
CLASS="classname"
>UNSIGNED-BYTE</TT
></A
> 16)</TT
></TD
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><SPAN
CLASS="type"
>uint16</SPAN
></TD
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><SPAN
CLASS="type"
>SHORT CARDINAL</SPAN
></TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><SPAN
CLASS="type"
>sint16</SPAN
></TD
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><TT
CLASS="type"
>(<A
HREF="http://www.lisp.org/HyperSpec/Body/typ_signed-byte.html"
TARGET="_top"
><TT
CLASS="classname"
>SIGNED-BYTE</TT
></A
> 16)</TT
></TD
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><SPAN
CLASS="type"
>sint16</SPAN
></TD
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><SPAN
CLASS="type"
>SHORT INTEGER</SPAN
></TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><SPAN
CLASS="type"
>uint32</SPAN
></TD
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><TT
CLASS="type"
>(<A
HREF="http://www.lisp.org/HyperSpec/Body/typ_unsigned-byte.html"
TARGET="_top"
><TT
CLASS="classname"
>UNSIGNED-BYTE</TT
></A
> 32)</TT
></TD
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><SPAN
CLASS="type"
>uint32</SPAN
></TD
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><SPAN
CLASS="type"
>CARDINAL</SPAN
></TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><SPAN
CLASS="type"
>sint32</SPAN
></TD
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><TT
CLASS="type"
>(<A
HREF="http://www.lisp.org/HyperSpec/Body/typ_signed-byte.html"
TARGET="_top"
><TT
CLASS="classname"
>SIGNED-BYTE</TT
></A
> 32)</TT
></TD
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><SPAN
CLASS="type"
>sint32</SPAN
></TD
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><SPAN
CLASS="type"
>INTEGER</SPAN
></TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><SPAN
CLASS="type"
>uint64</SPAN
></TD
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><TT
CLASS="type"
>(<A
HREF="http://www.lisp.org/HyperSpec/Body/typ_unsigned-byte.html"
TARGET="_top"
><TT
CLASS="classname"
>UNSIGNED-BYTE</TT
></A
> 64)</TT
></TD
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><SPAN
CLASS="type"
>uint64</SPAN
></TD
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><SPAN
CLASS="type"
>LONG CARDINAL</SPAN
></TD
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
>does not work on all platforms</TD
></TR
><TR
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><SPAN
CLASS="type"
>sint64</SPAN
></TD
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><TT
CLASS="type"
>(<A
HREF="http://www.lisp.org/HyperSpec/Body/typ_signed-byte.html"
TARGET="_top"
><TT
CLASS="classname"
>SIGNED-BYTE</TT
></A
> 64)</TT
></TD
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><SPAN
CLASS="type"
>sint64</SPAN
></TD
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><SPAN
CLASS="type"
>LONG INTEGER</SPAN
></TD
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
>does not work on all platforms</TD
></TR
><TR
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><A
HREF="http://www.lisp.org/HyperSpec/Body/typ_short-flo_m_long-float.html"
TARGET="_top"
><TT
CLASS="classname"
>SINGLE-FLOAT</TT
></A
></TD
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><A
HREF="http://www.lisp.org/HyperSpec/Body/typ_short-flo_m_long-float.html"
TARGET="_top"
><TT
CLASS="classname"
>SINGLE-FLOAT</TT
></A
></TD
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><SPAN
CLASS="type"
>float</SPAN
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><A
HREF="http://www.lisp.org/HyperSpec/Body/typ_short-flo_m_long-float.html"
TARGET="_top"
><TT
CLASS="classname"
>DOUBLE-FLOAT</TT
></A
></TD
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><A
HREF="http://www.lisp.org/HyperSpec/Body/typ_short-flo_m_long-float.html"
TARGET="_top"
><TT
CLASS="classname"
>DOUBLE-FLOAT</TT
></A
></TD
><TD
ALIGN="CENTER"
VALIGN="MIDDLE"
><SPAN
CLASS="type"
>double</SPAN
></TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></P
></DD
><DT
><A
NAME="c-pointer"
></A
><A
HREF="dffi.html#c-pointer"
><SPAN
CLASS="type"
>FFI:C-POINTER</SPAN
></A
></DT
><DD
><P
ALIGN="justify"
>This type corresponds to what <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
> calls
   <SPAN
CLASS="type"
>void*</SPAN
>, an opaque pointer.
   When used as an argument, <A
HREF="http://www.lisp.org/HyperSpec/Body/convar_nil.html"
TARGET="_top"
><TT
CLASS="constant"
>NIL</TT
></A
> is accepted as a <A
HREF="dffi.html#c-pointer"
><SPAN
CLASS="type"
>FFI:C-POINTER</SPAN
></A
> and
   treated as <TT
CLASS="constant"
>NULL</TT
>; when a function wants to return a <TT
CLASS="constant"
>NULL</TT
>
   <A
HREF="dffi.html#c-pointer"
><SPAN
CLASS="type"
>FFI:C-POINTER</SPAN
></A
>, it actually returns <A
HREF="http://www.lisp.org/HyperSpec/Body/convar_nil.html"
TARGET="_top"
><TT
CLASS="constant"
>NIL</TT
></A
>.
</P
></DD
><DT
><A
NAME="c-string"
></A
><A
HREF="dffi.html#c-string"
><SPAN
CLASS="type"
>FFI:C-STRING</SPAN
></A
></DT
><DD
><P
ALIGN="justify"
>This type corresponds to what <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
> calls
  <SPAN
CLASS="type"
>char*</SPAN
>, a zero-terminated string.  Its Lisp equivalent is
  a string, without the trailing zero character.
 </P
></DD
><DT
><A
NAME="c-struct"
></A
><TT
CLASS="type"
>(<A
HREF="dffi.html#c-struct"
><SPAN
CLASS="type"
>FFI:C-STRUCT</SPAN
></A
>
  <TT
CLASS="replaceable"
><I
>class</I
></TT
> (<TT
CLASS="replaceable"
><I
>ident<SUB
>1</SUB
></I
></TT
>
   <TT
CLASS="replaceable"
><I
>c-type<SUB
>1</SUB
></I
></TT
>) ...
  (<TT
CLASS="replaceable"
><I
>ident<SUB
>n</SUB
></I
></TT
>
   <TT
CLASS="replaceable"
><I
>c-type<SUB
>n</SUB
></I
></TT
>))</TT
></DT
><DD
><P
ALIGN="justify"
>This type is equivalent to what <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
> calls
 <SPAN
CLASS="type"
>struct { <TT
CLASS="replaceable"
><I
>c-type<SUB
>1</SUB
></I
></TT
>
 <TT
CLASS="replaceable"
><I
>ident<SUB
>1</SUB
></I
></TT
>; ...;
 <TT
CLASS="replaceable"
><I
>c-type<SUB
>n</SUB
></I
></TT
>
 <TT
CLASS="replaceable"
><I
>ident<SUB
>n</SUB
></I
></TT
>; }</SPAN
>.
 Its Lisp equivalent is: if <TT
CLASS="replaceable"
><I
>class</I
></TT
> is <A
HREF="http://www.lisp.org/HyperSpec/Body/syscla_vector.html"
TARGET="_top"
><TT
CLASS="classname"
>VECTOR</TT
></A
>, a
 <A
HREF="http://www.lisp.org/HyperSpec/Body/typ_simple-vector.html"
TARGET="_top"
><TT
CLASS="classname"
>SIMPLE-VECTOR</TT
></A
>; if <TT
CLASS="replaceable"
><I
>class</I
></TT
> is <A
HREF="http://www.lisp.org/HyperSpec/Body/syscla_list.html"
TARGET="_top"
><TT
CLASS="classname"
>LIST</TT
></A
>, a
 <A
HREF="http://www.lisp.org/HyperSpec/Body/glo_p.html#proper_list"
TARGET="_top"
>proper list</A
>;
 if <TT
CLASS="replaceable"
><I
>class</I
></TT
> is a symbol naming a structure or <B
CLASS="command"
>CLOS</B
> class, an
 instance of this class, with slots of names
 <TT
CLASS="replaceable"
><I
>ident<SUB
>1</SUB
></I
></TT
>, ...,
 <TT
CLASS="replaceable"
><I
>ident<SUB
>n</SUB
></I
></TT
>.</P
><P
ALIGN="justify"
>&#13; <TT
CLASS="replaceable"
><I
>class</I
></TT
> may also be a <A
HREF="http://www.lisp.org/HyperSpec/Body/syscla_cons.html"
TARGET="_top"
><TT
CLASS="classname"
>CONS</TT
></A
> of a <A
HREF="http://www.lisp.org/HyperSpec/Body/syscla_symbol.html"
TARGET="_top"
><TT
CLASS="classname"
>SYMBOL</TT
></A
> (as above) and
 a <A
HREF="http://www.lisp.org/HyperSpec/Body/syscla_list.html"
TARGET="_top"
><TT
CLASS="classname"
>LIST</TT
></A
> of <A
HREF="dffi.html#def-c-struct"
><TT
CLASS="function"
>FFI:DEF-C-STRUCT</TT
></A
> options.
 </P
></DD
><DT
><A
NAME="c-union"
></A
><TT
CLASS="type"
>(<A
HREF="dffi.html#c-union"
><SPAN
CLASS="type"
>FFI:C-UNION</SPAN
></A
>
  (<TT
CLASS="replaceable"
><I
>ident<SUB
>1</SUB
></I
></TT
>
   <TT
CLASS="replaceable"
><I
>c-type<SUB
>1</SUB
></I
></TT
>) ...
  (<TT
CLASS="replaceable"
><I
>ident<SUB
>n</SUB
></I
></TT
>
   <TT
CLASS="replaceable"
><I
>c-type<SUB
>n</SUB
></I
></TT
>))</TT
></DT
><DD
><P
ALIGN="justify"
>This type is equivalent to what <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
> calls
  <SPAN
CLASS="type"
>union { <TT
CLASS="replaceable"
><I
>c-type<SUB
>1</SUB
></I
></TT
>
  <TT
CLASS="replaceable"
><I
>ident<SUB
>1</SUB
></I
></TT
>; ...;
  <TT
CLASS="replaceable"
><I
>c-type<SUB
>n</SUB
></I
></TT
>
  <TT
CLASS="replaceable"
><I
>ident<SUB
>n</SUB
></I
></TT
>;
  }</SPAN
>.
  Conversion to and from Lisp assumes that a value is to be viewed as
  being of <TT
CLASS="replaceable"
><I
>c-type<SUB
>1</SUB
></I
></TT
>.
 </P
></DD
><DT
><A
NAME="c-array"
></A
><TT
CLASS="type"
>(<A
HREF="dffi.html#c-array"
><SPAN
CLASS="type"
>FFI:C-ARRAY</SPAN
></A
>
   <TT
CLASS="replaceable"
><I
>c-type</I
></TT
> <TT
CLASS="replaceable"
><I
>dim<SUB
>1</SUB
></I
></TT
>)</TT
><BR><TT
CLASS="type"
>(<A
HREF="dffi.html#c-array"
><SPAN
CLASS="type"
>FFI:C-ARRAY</SPAN
></A
>
   <TT
CLASS="replaceable"
><I
>c-type</I
></TT
> (<TT
CLASS="replaceable"
><I
>dim<SUB
>1</SUB
></I
></TT
> ...
   <TT
CLASS="replaceable"
><I
>dim<SUB
>n</SUB
></I
></TT
>))</TT
></DT
><DD
><P
ALIGN="justify"
>This type is equivalent to what <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
> calls
  <SPAN
CLASS="type"
><TT
CLASS="replaceable"
><I
>c-type</I
></TT
> [<TT
CLASS="replaceable"
><I
>dim<SUB
>1</SUB
></I
></TT
>]
  ... [<TT
CLASS="replaceable"
><I
>dim<SUB
>n</SUB
></I
></TT
>]</SPAN
>.
  Note that when an array is passed as an argument to a function in
  <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
>, it is actually passed as a pointer; you therefore have to
  write <TT
CLASS="type"
>(<A
HREF="dffi.html#c-ptr"
><SPAN
CLASS="type"
>FFI:C-PTR</SPAN
></A
> (<A
HREF="dffi.html#c-array"
><SPAN
CLASS="type"
>FFI:C-ARRAY</SPAN
></A
> ...))</TT
> for this
  argument's type.</P
></DD
><DT
><A
NAME="c-array-max"
></A
><TT
CLASS="type"
>(<A
HREF="dffi.html#c-array-max"
><SPAN
CLASS="type"
>FFI:C-ARRAY-MAX</SPAN
></A
>
  <TT
CLASS="replaceable"
><I
>c-type</I
></TT
> <TT
CLASS="replaceable"
><I
>maxdimension</I
></TT
>)</TT
></DT
><DD
><P
ALIGN="justify"
>This type is equivalent to what <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
> calls
  <SPAN
CLASS="type"
><TT
CLASS="replaceable"
><I
>c-type</I
></TT
> [<TT
CLASS="replaceable"
><I
>maxdimension</I
></TT
>]</SPAN
>, an array containing up to
  <TT
CLASS="replaceable"
><I
>maxdimension</I
></TT
> elements.
  The array is zero-terminated if it contains less than <TT
CLASS="replaceable"
><I
>maxdimension</I
></TT
> elements.
  Conversion from Lisp of an array with more than <TT
CLASS="replaceable"
><I
>maxdimension</I
></TT
> elements
  silently ignores the superfluous elements.
  </P
></DD
><DT
><A
NAME="c-function"
></A
><TT
CLASS="type"
>(<A
HREF="dffi.html#c-function"
><SPAN
CLASS="type"
>FFI:C-FUNCTION</SPAN
></A
> (<TT
CLASS="constant"
>:ARGUMENTS</TT
>
      {(<TT
CLASS="replaceable"
><I
>argument</I
></TT
> <TT
CLASS="replaceable"
><I
>a-c-type</I
></TT
>
        [<A
HREF="dffi.html#param-mode"
><TT
CLASS="replaceable"
><I
>PARAM-MODE</I
></TT
></A
> [<A
HREF="dffi.html#allocation"
><TT
CLASS="replaceable"
><I
>ALLOCATION</I
></TT
></A
>]])}*)
    (<TT
CLASS="constant"
>:RETURN-TYPE</TT
> <TT
CLASS="replaceable"
><I
>r-c-type</I
></TT
> [<A
HREF="dffi.html#allocation"
><TT
CLASS="replaceable"
><I
>ALLOCATION</I
></TT
></A
>])
    (<A
HREF="dffi.html#c-flavor"
><TT
CLASS="constant"
>:LANGUAGE</TT
></A
> <TT
CLASS="replaceable"
><I
>language</I
></TT
>))</TT
></DT
><DD
><P
ALIGN="justify"
>This type designates a <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
> function that can be
  called according to the given prototype <TT
CLASS="sexp"
>(<TT
CLASS="replaceable"
><I
>r-c-type</I
></TT
> (*)
  (<TT
CLASS="replaceable"
><I
>a-c-type<SUB
>1</SUB
></I
></TT
>, ...))</TT
>.
  Conversion between <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
> functions and Lisp functions
  is transparent, and <TT
CLASS="constant"
>NULL</TT
>/<A
HREF="http://www.lisp.org/HyperSpec/Body/convar_nil.html"
TARGET="_top"
><TT
CLASS="constant"
>NIL</TT
></A
> is recognized and
  accepted.</P
></DD
><DT
><A
NAME="c-ptr"
></A
><TT
CLASS="type"
>(<A
HREF="dffi.html#c-ptr"
><SPAN
CLASS="type"
>FFI:C-PTR</SPAN
></A
>
              <TT
CLASS="replaceable"
><I
>c-type</I
></TT
>)</TT
></DT
><DD
><P
ALIGN="justify"
>This type is equivalent to what <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
> calls
  <SPAN
CLASS="type"
><TT
CLASS="replaceable"
><I
>c-type</I
></TT
> *</SPAN
>: a pointer to a single item of the given
  <TT
CLASS="replaceable"
><I
>c-type</I
></TT
>.</P
></DD
><DT
><A
NAME="c-ptr-null"
></A
><TT
CLASS="type"
>(<A
HREF="dffi.html#c-ptr-null"
><SPAN
CLASS="type"
>FFI:C-PTR-NULL</SPAN
></A
> <TT
CLASS="replaceable"
><I
>c-type</I
></TT
>)</TT
></DT
><DD
><P
ALIGN="justify"
>This type is also equivalent to what <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
> calls
  <SPAN
CLASS="type"
><TT
CLASS="replaceable"
><I
>c-type</I
></TT
> *</SPAN
>: a pointer to a single item of the given
  <TT
CLASS="replaceable"
><I
>c-type</I
></TT
>, with the exception that <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
> <TT
CLASS="constant"
>NULL</TT
> corresponds to
  Lisp <A
HREF="http://www.lisp.org/HyperSpec/Body/convar_nil.html"
TARGET="_top"
><TT
CLASS="constant"
>NIL</TT
></A
>.</P
></DD
><DT
><A
NAME="c-array-ptr"
></A
><TT
CLASS="type"
>(<A
HREF="dffi.html#c-array-ptr"
><SPAN
CLASS="type"
>FFI:C-ARRAY-PTR</SPAN
></A
> <TT
CLASS="replaceable"
><I
>c-type</I
></TT
>)</TT
></DT
><DD
><P
ALIGN="justify"
>This type is equivalent to what <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
> calls
  <SPAN
CLASS="type"
><TT
CLASS="replaceable"
><I
>c-type</I
></TT
> (*)[]</SPAN
>: a pointer to a zero-terminated array of
  items of the given <TT
CLASS="replaceable"
><I
>c-type</I
></TT
>.</P
></DD
></DL
></DIV
><P
ALIGN="justify"
><A
HREF="encoding.html#foreign-enc"
><TT
CLASS="varname"
>CUSTOM:*FOREIGN-ENCODING*</TT
></A
> governs conversion for any <TT
CLASS="replaceable"
><I
>c-type</I
></TT
> involving
 <A
HREF="dffi.html#c-string"
><SPAN
CLASS="type"
>FFI:C-STRING</SPAN
></A
> or <A
HREF="http://www.lisp.org/HyperSpec/Body/syscla_character.html"
TARGET="_top"
><TT
CLASS="classname"
>CHARACTER</TT
></A
> (but not <SPAN
CLASS="type"
>char</SPAN
>).</P
></DIV
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="c-flavor"
></A
>30.3.3. The choice of the <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
> flavor.</H2
><P
ALIGN="justify"
><A
HREF="dffi.html#c-function"
><SPAN
CLASS="type"
>FFI:C-FUNCTION</SPAN
></A
>, <A
HREF="dffi.html#def-call-in"
><TT
CLASS="function"
>FFI:DEF-CALL-IN</TT
></A
>, <A
HREF="dffi.html#def-call-out"
><TT
CLASS="function"
>FFI:DEF-CALL-OUT</TT
></A
> take <A
HREF="dffi.html#c-flavor"
><TT
CLASS="constant"
>:LANGUAGE</TT
></A
> argument.
The <TT
CLASS="replaceable"
><I
>language</I
></TT
> is either <TT
CLASS="constant"
>:C</TT
> (denotes K&#38;R <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
>) or <TT
CLASS="constant"
>:STDC</TT
>
(denotes ANSI <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
>) or <TT
CLASS="constant"
>:STDC-STDCALL</TT
> (denotes ANSI <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
>
with the <I
CLASS="emphasis"
>stdcall</I
> calling convention).
It specifies whether the <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
> function (caller or callee) has been
compiled by a K&#38;R <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
> compiler or by an ANSI <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
> compiler,
and possibly the calling convention.</P
><P
ALIGN="justify"
>The default language is set using the macro
 <TT
CLASS="function"
>FFI:DEFAULT-FOREIGN-LANGUAGE</TT
>.
If this macro has not been called in the current
 <A
HREF="http://www.lisp.org/HyperSpec/Body/glo_c.html#compilation_unit"
TARGET="_top"
>compilation
unit</A
> (usually a file), a warning is issued and
<TT
CLASS="constant"
>:STDC</TT
> is used for the rest of the unit.</P
></DIV
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="dffi-variables"
></A
>30.3.4. Foreign variables</H2
><P
ALIGN="justify"
>Foreign variables are variables whose storage is allocated in the
 foreign language module.  They can nevertheless be evaluated and
 modified through <A
HREF="http://www.lisp.org/HyperSpec/Body/spefor_setq.html"
TARGET="_top"
><TT
CLASS="function"
>SETQ</TT
></A
>, just as normal variables can, except that the
 range of allowed values is limited according to the variable's foreign
 type.  Note that for a foreign variable <TT
CLASS="replaceable"
><I
>x</I
></TT
> the form <TT
CLASS="sexp"
>(<A
HREF="http://www.lisp.org/HyperSpec/Body/fun_eql.html"
TARGET="_top"
><TT
CLASS="function"
>EQL</TT
></A
> <TT
CLASS="replaceable"
><I
>x</I
></TT
> <TT
CLASS="replaceable"
><I
>x</I
></TT
>)</TT
> is not necessarily true,
 since every time <TT
CLASS="replaceable"
><I
>x</I
></TT
> is evaluated its foreign value is converted to a
 <A
HREF="http://www.lisp.org/HyperSpec/Body/glo_f.html#fresh"
TARGET="_top"
>fresh</A
> Lisp value.  Foreign variables are defined using
 <A
HREF="dffi.html#def-c-var"
><TT
CLASS="function"
>FFI:DEF-C-VAR</TT
></A
>.</P
></DIV
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="dffi-places"
></A
>30.3.5. Operations on foreign places</H2
><P
ALIGN="justify"
>A <A
HREF="dffi.html#dffi-variables"
><TT
CLASS="classname"
>FFI:FOREIGN-VARIABLE</TT
></A
> <TT
CLASS="replaceable"
><I
>name</I
></TT
> defined by <A
HREF="dffi.html#def-c-var"
><TT
CLASS="function"
>FFI:DEF-C-VAR</TT
></A
>, <A
HREF="dffi.html#foreign-stack"
><TT
CLASS="function"
>FFI:WITH-C-VAR</TT
></A
>
 or <A
HREF="dffi.html#with-c-place"
><TT
CLASS="function"
>FFI:WITH-C-PLACE</TT
></A
> defines a <A
HREF="http://www.lisp.org/HyperSpec/Body/glo_p.html#place"
TARGET="_top"
>place</A
>,
 i.e., a form which can also be used as argument to <A
HREF="http://www.lisp.org/HyperSpec/Body/mac_setfcm_psetf.html"
TARGET="_top"
><TT
CLASS="function"
>SETF</TT
></A
>.
 (An "lvalue" in <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
> terminology.)
 The following operations are available on foreign places:
 <A
HREF="dffi.html#element"
><TT
CLASS="function"
>FFI:ELEMENT</TT
></A
>, <A
HREF="dffi.html#deref"
><TT
CLASS="function"
>FFI:DEREF</TT
></A
>, <A
HREF="dffi.html#slot"
><TT
CLASS="function"
>FFI:SLOT</TT
></A
>, <A
HREF="dffi.html#cast"
><TT
CLASS="function"
>FFI:CAST</TT
></A
>, <A
HREF="dffi.html#offset"
><TT
CLASS="function"
>FFI:OFFSET</TT
></A
>, <A
HREF="dffi.html#c-var-addr"
><TT
CLASS="function"
>FFI:C-VAR-ADDRESS</TT
></A
>,
 <A
HREF="dffi.html#c-var-object"
><TT
CLASS="function"
>FFI:C-VAR-OBJECT</TT
></A
>, <A
HREF="dffi.html#typeof"
><TT
CLASS="function"
>FFI:TYPEOF</TT
></A
>, <A
HREF="dffi.html#sizeof"
><TT
CLASS="function"
>FFI:SIZEOF</TT
></A
>, <A
HREF="dffi.html#bitsizeof"
><TT
CLASS="function"
>FFI:BITSIZEOF</TT
></A
>.</P
></DIV
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="dffi-functions"
></A
>30.3.6. Foreign functions</H2
><P
ALIGN="justify"
>Foreign functions are functions which are defined in the foreign
 language.  There are <I
CLASS="emphasis"
>named foreign functions</I
>
 (imported via <A
HREF="dffi.html#def-call-out"
><TT
CLASS="function"
>FFI:DEF-CALL-OUT</TT
></A
> or created via <A
HREF="dffi.html#def-call-in"
><TT
CLASS="function"
>FFI:DEF-CALL-IN</TT
></A
>) and
 <I
CLASS="emphasis"
>anonymous foreign functions</I
>; they arise through
 conversion of function pointers.</P
><P
ALIGN="justify"
>A <I
CLASS="emphasis"
>"call-out"</I
> function is a foreign function
 called from Lisp: control flow temporarily leaves Lisp.  A
 <I
CLASS="emphasis"
>"call-in"</I
> function is a Lisp function called from
 the foreign language: control flow temporary enters Lisp.</P
><P
ALIGN="justify"
>The following forms define foreign functions: <A
HREF="dffi.html#def-call-in"
><TT
CLASS="function"
>FFI:DEF-CALL-IN</TT
></A
>,
 <A
HREF="dffi.html#def-call-out"
><TT
CLASS="function"
>FFI:DEF-CALL-OUT</TT
></A
>, <A
HREF="dffi.html#def-c-call-in"
><TT
CLASS="function"
>FFI:DEF-C-CALL-IN</TT
></A
>, <A
HREF="dffi.html#def-c-call-out"
><TT
CLASS="function"
>FFI:DEF-C-CALL-OUT</TT
></A
>.</P
></DIV
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="allocation"
></A
>30.3.7. Argument and result passing conventions</H2
><P
ALIGN="justify"
>When passed to and from functions, allocation of arguments and
 results is handled as follows:</P
><P
ALIGN="justify"
>Values of <A
HREF="dffi.html#simple-c-type"
><TT
CLASS="replaceable"
><I
>SIMPLE-C-TYPE</I
></TT
></A
>, <A
HREF="dffi.html#c-pointer"
><SPAN
CLASS="type"
>FFI:C-POINTER</SPAN
></A
> are passed on the stack,
 with dynamic extent. The <A
HREF="dffi.html#allocation"
><TT
CLASS="replaceable"
><I
>ALLOCATION</I
></TT
></A
> is effectively ignored.</P
><P
ALIGN="justify"
>Values of type <A
HREF="dffi.html#c-string"
><SPAN
CLASS="type"
>FFI:C-STRING</SPAN
></A
>, <A
HREF="dffi.html#c-ptr"
><SPAN
CLASS="type"
>FFI:C-PTR</SPAN
></A
>, <A
HREF="dffi.html#c-ptr-null"
><SPAN
CLASS="type"
>FFI:C-PTR-NULL</SPAN
></A
>, <A
HREF="dffi.html#c-array-ptr"
><SPAN
CLASS="type"
>FFI:C-ARRAY-PTR</SPAN
></A
>
 need storage.  The <A
HREF="dffi.html#allocation"
><TT
CLASS="replaceable"
><I
>ALLOCATION</I
></TT
></A
> specifies the allocation policy:
<DIV
CLASS="informaltable"
><A
NAME="allocation-tab"
></A
><P
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
><A
HREF="dffi.html#allocation"
><TT
CLASS="replaceable"
><I
>ALLOCATION</I
></TT
></A
></TH
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>meaning</TH
></TR
></THEAD
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="constant"
>:NONE</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>no storage is allocated.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="constant"
>:ALLOCA</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>allocation of storage on the
   stack, which has dynamic extent.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TT
CLASS="constant"
>:MALLOC-FREE</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>storage will be allocated via
   <A
HREF="http://www.opengroup.org/onlinepubs/007904975/functions/malloc.html"
TARGET="_top"
><TT
CLASS="function"
>malloc</TT
></A
> and freed via <A
HREF="http://www.opengroup.org/onlinepubs/007904975/functions/free.html"
TARGET="_top"
><TT
CLASS="function"
>free</TT
></A
>.</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></P
><P
ALIGN="justify"
>If no <A
HREF="dffi.html#allocation"
><TT
CLASS="replaceable"
><I
>ALLOCATION</I
></TT
></A
> is specified, the default <A
HREF="dffi.html#allocation"
><TT
CLASS="replaceable"
><I
>ALLOCATION</I
></TT
></A
> is
 <TT
CLASS="constant"
>:NONE</TT
> for most types, but <TT
CLASS="constant"
>:ALLOCA</TT
> for <A
HREF="dffi.html#c-string"
><SPAN
CLASS="type"
>FFI:C-STRING</SPAN
></A
> and <A
HREF="dffi.html#c-ptr"
><SPAN
CLASS="type"
>FFI:C-PTR</SPAN
></A
> and
 <A
HREF="dffi.html#c-ptr-null"
><SPAN
CLASS="type"
>FFI:C-PTR-NULL</SPAN
></A
> and <A
HREF="dffi.html#c-array-ptr"
><SPAN
CLASS="type"
>FFI:C-ARRAY-PTR</SPAN
></A
> and for <TT
CLASS="constant"
>:OUT</TT
> arguments. [Subject to
 change!]  The <TT
CLASS="constant"
>:MALLOC-FREE</TT
> policy provides the ability to pass
 arbitrarily nested structs containing pointers pointing to structs
 ... within a single conversion.</P
><P
></P
><DIV
CLASS="variablelist"
><DL
><DT
>For call-out functions:</DT
><DD
><P
></P
><DIV
CLASS="variablelist"
><DL
><DT
>For arguments passed from Lisp to <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
>:</DT
><DD
><P
></P
><DIV
CLASS="variablelist"
><DL
><DT
>If <A
HREF="dffi.html#allocation"
><TT
CLASS="replaceable"
><I
>ALLOCATION</I
></TT
></A
> is <TT
CLASS="constant"
>:MALLOC-FREE</TT
>:</DT
><DD
><P
ALIGN="justify"
>Lisp allocates the storage using <A
HREF="http://www.opengroup.org/onlinepubs/007904975/functions/malloc.html"
TARGET="_top"
><TT
CLASS="function"
>malloc</TT
></A
> and
     never deallocates it.  The <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
> function is supposed to call
     <A
HREF="http://www.opengroup.org/onlinepubs/007904975/functions/free.html"
TARGET="_top"
><TT
CLASS="function"
>free</TT
></A
> when done with it.</P
></DD
><DT
>If <A
HREF="dffi.html#allocation"
><TT
CLASS="replaceable"
><I
>ALLOCATION</I
></TT
></A
> is <TT
CLASS="constant"
>:ALLOCA</TT
>:</DT
><DD
><P
ALIGN="justify"
>Lisp allocates the storage on the stack, with
     dynamic extent.  It is freed when the <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
> function returns.
    </P
></DD
><DT
>If <A
HREF="dffi.html#allocation"
><TT
CLASS="replaceable"
><I
>ALLOCATION</I
></TT
></A
> is <TT
CLASS="constant"
>:NONE</TT
>:</DT
><DD
><P
ALIGN="justify"
>Lisp assumes that the pointer already points to a
     valid area of the proper size and puts the result value there.
     This is dangerous! and deprecated.
    </P
></DD
></DL
></DIV
></DD
><DT
>For results passed from <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
> to Lisp:</DT
><DD
><P
></P
><DIV
CLASS="variablelist"
><DL
><DT
>If <A
HREF="dffi.html#allocation"
><TT
CLASS="replaceable"
><I
>ALLOCATION</I
></TT
></A
> is <TT
CLASS="constant"
>:MALLOC-FREE</TT
>:</DT
><DD
><P
ALIGN="justify"
>Lisp calls <A
HREF="http://www.opengroup.org/onlinepubs/007904975/functions/free.html"
TARGET="_top"
><TT
CLASS="function"
>free</TT
></A
> on it when done.
    </P
></DD
><DT
>If <A
HREF="dffi.html#allocation"
><TT
CLASS="replaceable"
><I
>ALLOCATION</I
></TT
></A
> is <TT
CLASS="constant"
>:NONE</TT
>:</DT
><DD
><P
ALIGN="justify"
>Lisp does nothing.
    </P
></DD
></DL
></DIV
></DD
></DL
></DIV
></DD
><DT
>For call-in functions:</DT
><DD
><P
></P
><DIV
CLASS="variablelist"
><DL
><DT
>For arguments passed from <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
> to Lisp:</DT
><DD
><P
></P
><DIV
CLASS="variablelist"
><DL
><DT
>If <A
HREF="dffi.html#allocation"
><TT
CLASS="replaceable"
><I
>ALLOCATION</I
></TT
></A
> is <TT
CLASS="constant"
>:MALLOC-FREE</TT
>:</DT
><DD
><P
ALIGN="justify"
>Lisp calls <A
HREF="http://www.opengroup.org/onlinepubs/007904975/functions/free.html"
TARGET="_top"
><TT
CLASS="function"
>free</TT
></A
> on it when done.
     </P
></DD
><DT
>If <A
HREF="dffi.html#allocation"
><TT
CLASS="replaceable"
><I
>ALLOCATION</I
></TT
></A
> is <TT
CLASS="constant"
>:ALLOCA</TT
> or <TT
CLASS="constant"
>:NONE</TT
>:</DT
><DD
><P
ALIGN="justify"
>Lisp does nothing.
     </P
></DD
></DL
></DIV
></DD
><DT
>For results passed from Lisp to <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
>:</DT
><DD
><P
></P
><DIV
CLASS="variablelist"
><DL
><DT
>If <A
HREF="dffi.html#allocation"
><TT
CLASS="replaceable"
><I
>ALLOCATION</I
></TT
></A
> is <TT
CLASS="constant"
>:MALLOC-FREE</TT
>:</DT
><DD
><P
ALIGN="justify"
>Lisp allocates the storage using <A
HREF="http://www.opengroup.org/onlinepubs/007904975/functions/malloc.html"
TARGET="_top"
><TT
CLASS="function"
>malloc</TT
></A
> and
      never deallocates it.  The <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
> function is supposed to call
      <A
HREF="http://www.opengroup.org/onlinepubs/007904975/functions/free.html"
TARGET="_top"
><TT
CLASS="function"
>free</TT
></A
> when done with it.</P
></DD
><DT
>If <A
HREF="dffi.html#allocation"
><TT
CLASS="replaceable"
><I
>ALLOCATION</I
></TT
></A
> is <TT
CLASS="constant"
>:NONE</TT
>:</DT
><DD
><P
ALIGN="justify"
>Lisp assumes that the pointer already points to a
     valid area of the proper size and puts the result value there.
     This is dangerous! and deprecated.
    </P
></DD
></DL
></DIV
></DD
></DL
></DIV
></DD
></DL
></DIV
><P
></P
><DIV
CLASS="variablelist"
><DL
><DT
>Platform dependent: <A
HREF="http://www.amiga.org/"
TARGET="_top"
><B
CLASS="emphasis"
>Amiga</B
></A
> platforms only.</DT
><DD
><P
ALIGN="justify"
><A
HREF="dffi.html#allocation"
><TT
CLASS="replaceable"
><I
>ALLOCATION</I
></TT
></A
> may not be <TT
CLASS="constant"
>:MALLOC-FREE</TT
> because there
 is no commonly used <A
HREF="http://www.opengroup.org/onlinepubs/007904975/functions/malloc.html"
TARGET="_top"
><TT
CLASS="function"
>malloc</TT
></A
>/<A
HREF="http://www.opengroup.org/onlinepubs/007904975/functions/free.html"
TARGET="_top"
><TT
CLASS="function"
>free</TT
></A
> library function.</P
><P
ALIGN="justify"
>The <A
HREF="dffi.html#allocation"
><TT
CLASS="replaceable"
><I
>ALLOCATION</I
></TT
></A
> may be followed by a register specification,
 any of the symbols <TT
CLASS="constant"
>:d0</TT
>, <TT
CLASS="constant"
>:d1</TT
>,
 <TT
CLASS="constant"
>:d2</TT
>, <TT
CLASS="constant"
>:d3</TT
>,
 <TT
CLASS="constant"
>:d4</TT
>, <TT
CLASS="constant"
>:d5</TT
>,
 <TT
CLASS="constant"
>:d6</TT
>, <TT
CLASS="constant"
>:d7</TT
>,
 <TT
CLASS="constant"
>:a0</TT
>, <TT
CLASS="constant"
>:a1</TT
>,
 <TT
CLASS="constant"
>:a2</TT
>, <TT
CLASS="constant"
>:a3</TT
>,
 <TT
CLASS="constant"
>:a4</TT
>, <TT
CLASS="constant"
>:a5</TT
>,
 <TT
CLASS="constant"
>:a6</TT
>, each representing one 680x0 register.
 This works only for integral types: integers, pointers, <A
HREF="dffi.html#c-string"
><SPAN
CLASS="type"
>FFI:C-STRING</SPAN
></A
>,
 <A
HREF="dffi.html#c-function"
><SPAN
CLASS="type"
>FFI:C-FUNCTION</SPAN
></A
>.
</P
></DD
></DL
></DIV
><DIV
CLASS="warning"
><A
NAME="ffi-struct-arg"
></A
><P
></P
><TABLE
CLASS="warning"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="/usr/share/sgml/docbook/dsssl-stylesheets/images/warning.gif"
HSPACE="5"
ALT="Warning"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
ALIGN="justify"
>Passing <A
HREF="dffi.html#c-struct"
><SPAN
CLASS="type"
>FFI:C-STRUCT</SPAN
></A
>, <A
HREF="dffi.html#c-union"
><SPAN
CLASS="type"
>FFI:C-UNION</SPAN
></A
>,
  <A
HREF="dffi.html#c-array"
><SPAN
CLASS="type"
>FFI:C-ARRAY</SPAN
></A
>, <A
HREF="dffi.html#c-array-max"
><SPAN
CLASS="type"
>FFI:C-ARRAY-MAX</SPAN
></A
> values as arguments (not via pointers) is
  only possible to the extent the <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
> compiler supports it.
  Most <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
> compilers do it right, but some <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
> compilers
  (such as gcc on hppa and win32) have problems with this.
  The recommended workaround is to pass pointers; this is fully supported.
  See also this <TT
CLASS="email"
>&#60;<A
HREF="mailto:clisp-list@sf.net"
>clisp-list@sf.net</A
>&#62;</TT
>
  <A
HREF="http://article.gmane.org/gmane.lisp.clisp.devel/10089"
TARGET="_top"
>message</A
>.</P
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="param-mode"
></A
>30.3.8. Parameter Mode</H2
><P
ALIGN="justify"
>A function parameter's <A
HREF="dffi.html#param-mode"
><TT
CLASS="replaceable"
><I
>PARAM-MODE</I
></TT
></A
> may be</P
><P
></P
><DIV
CLASS="variablelist"
><DL
><DT
><TT
CLASS="constant"
>:IN</TT
> (means: read-only):</DT
><DD
><P
ALIGN="justify"
>The caller passes information to the callee.
  </P
></DD
><DT
><TT
CLASS="constant"
>:OUT</TT
> (means: write-only):</DT
><DD
><P
ALIGN="justify"
>The callee passes information back to the caller on
   return.  When viewed as a Lisp function, there is no Lisp argument
   corresponding to this, instead it means an additional return value.
  </P
></DD
><DT
><TT
CLASS="constant"
>:IN-OUT</TT
> (means: read-write):</DT
><DD
><P
ALIGN="justify"
>Information is passed from the caller to the callee
   and then back to the caller.  When viewed as a Lisp function, the
   <TT
CLASS="constant"
>:OUT</TT
> value is returned as an additional multiple value.
  </P
></DD
></DL
></DIV
><P
ALIGN="justify"
>The default is <TT
CLASS="constant"
>:IN</TT
>.</P
><P
ALIGN="justify"
>[Currently, only <TT
CLASS="constant"
>:IN</TT
> is fully implemented.  <TT
CLASS="constant"
>:OUT</TT
> works only
 with <A
HREF="dffi.html#allocation"
><TT
CLASS="replaceable"
><I
>ALLOCATION</I
></TT
></A
> = <TT
CLASS="constant"
>:ALLOCA</TT
>.]</P
></DIV
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="dffi-examples"
></A
>30.3.9. Examples</H2
><DIV
CLASS="example"
><A
NAME="dffi-simple"
></A
><P
><B
>Example 30-3. Simple declarations and access</B
></P
><P
ALIGN="justify"
>The <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
> declaration

<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>&#13;struct foo {
    int a;
    struct foo * b[100];
};
</PRE
></TD
></TR
></TABLE
>

corresponds to

<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>&#13;(def-c-struct foo
  (a int)
  (b (c-array (c-ptr foo) 100)))
</PRE
></TD
></TR
></TABLE
></P
><P
ALIGN="justify"
>The element access

<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>&#13;struct foo f;
f.b[7].a
</PRE
></TD
></TR
></TABLE
>

corresponds to

<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>&#13;(declare (type foo f))
(foo-a (aref (foo-b f) 7)) or (slot-value (aref (slot-value f 'b) 7) 'a)
</PRE
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="example"
><A
NAME="dffi-extern-var"
></A
><P
><B
>Example 30-4. external <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
> variable and some accesses</B
></P
><P
ALIGN="justify"
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>&#13;struct bar {
    short x, y;
    char a, b;
    int z;
    struct bar * n;
};

extern struct bar * my_struct;

my_struct-&#62;x++;
my_struct-&#62;a = 5;
my_struct = my_struct-&#62;n;
</PRE
></TD
></TR
></TABLE
>

corresponds to

<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>&#13;(def-c-struct bar
  (x short)
  (y short)
  (a char)
  (b char) ; or (b character) if it represents a character, not a number
  (z int)
  (n (c-ptr bar)))

(def-c-var my_struct (:type (c-ptr bar)))

(setq my_struct (let ((s my_struct)) (incf (slot-value s 'x)) s))
or (incf (slot my_struct 'x))
(setq my_struct (let ((s my_struct)) (setf (slot-value s 'a) 5) s))
or (setf (slot my_struct 'a) 5)
(setq my_struct (slot-value my_struct 'n))
or (setq my_struct (deref (slot my_struct 'n)))
</PRE
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="example"
><A
NAME="dffi-extern-func1"
></A
><P
><B
>Example 30-5. Calling an external function</B
></P
><P
ALIGN="justify"
>On <A
HREF="ansi.html"
><TT
CLASS="varname"
>CUSTOM:*ANSI*</TT
></A
> <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
> systems, <A
HREF="http://www.opengroup.org/onlinepubs/007904975/basedefs/stdlib.h.html"
TARGET="_top"
><TT
CLASS="filename"
>stdlib.h</TT
></A
> contains the declarations:

<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>&#13;typedef struct {
  int quot;   /* Quotient */
  int rem;    /* Remainder */
} div_t;
extern div_t div (int numer, int denom);
</PRE
></TD
></TR
></TABLE
>

This translates to

<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>&#13;(def-c-struct (div_t :typedef)
  (quot int)
  (rem int))
(default-foreign-language :stdc)
(def-call-out div (:arguments (numer int) (denom int))
  (:return-type div_t))
</PRE
></TD
></TR
></TABLE
>

Sample call from within Lisp:

<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>&#13;&#62; (div 20 3)
#S(DIV_T :QUOT 6 :REM 2)
</PRE
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="example"
><A
NAME="dffi-extern-func2"
></A
><P
><B
>Example 30-6. Another example for calling an external function</B
></P
><P
ALIGN="justify"
>Suppose the following is defined in a file
 <TT
CLASS="filename"
>cfun.c</TT
>:

<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>&#13;struct cfunr { int x; char *s; };
struct cfunr * cfun (int i,char *s,struct cfunr * r,int a[10]) {
  int j;
  struct cfunr * r2;
  printf("i = %d\n", i);
  printf("s = %s\n", s);
  printf("r-&#62;x = %d\n", r-&#62;x);
  printf("r-&#62;s = %s\n", r-&#62;s);
  for (j = 0; j &#60; 10; j++) printf("a[%d] = %d.\n", j, a[j]);
  r2 = (struct cfunr *) malloc (sizeof (struct cfunr));
  r2-&#62;x = i+5;
  r2-&#62;s = "A C string";
  return r2;
}
</PRE
></TD
></TR
></TABLE
>

It is possible to call this function from Lisp using the file
<TT
CLASS="filename"
>callcfun.lisp</TT
> (do not call it
<TT
CLASS="filename"
>cfun.lisp</TT
> - <A
HREF="http://www.lisp.org/HyperSpec/Body/fun_compile-file.html"
TARGET="_top"
><TT
CLASS="function"
>COMPILE-FILE</TT
></A
> would overwrite
<TT
CLASS="filename"
>cfun.c</TT
>) whose contents is:

<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>&#13;(<A
HREF="http://www.lisp.org/HyperSpec/Body/mac_defpackage.html"
TARGET="_top"
><TT
CLASS="function"
>DEFPACKAGE</TT
></A
> "TEST-C-CALL" (:use "LISP" "FFI"))
(<A
HREF="http://www.lisp.org/HyperSpec/Body/mac_in-package.html"
TARGET="_top"
><TT
CLASS="function"
>IN-PACKAGE</TT
></A
> "TEST-C-CALL")
(def-c-struct cfunr (x int) (s c-string))
(default-foreign-language :stdc)
(def-call-out cfun
    (:arguments (i int)
                (s c-string)
                (r (c-ptr cfunr) :in :alloca)
                (a (c-ptr (c-array int 10)) :in :alloca))
  (:return-type (c-ptr cfunr)))
(defun call-cfun ()
  (cfun 5 "A Lisp string" (make-cfunr :x 10 :s "Another Lisp string")
        '#(0 1 2 3 4 5 6 7 8 9)))
</PRE
></TD
></TR
></TABLE
>

Use the <A
HREF="modules.html"
>module</A
> facility:

<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>&#13;$ clisp-link create-module-set cfun callcfun.c
$ cc -O -c cfun.c
$ cd cfun
$ ln -s ../cfun.o cfun.o
Add cfun.o to NEW_LIBS and NEW_FILES in link.sh.
$ cd ..
$ base/lisp.run -M base/lispinit.mem -c callcfun.lisp
$ clisp-link add-module-set cfun base base+cfun
$ base+cfun/lisp.run -M base+cfun/lispinit.mem -i callcfun
&#62; (test-c-call::call-cfun)
i = 5
s = A Lisp string
r-&#62;x = 10
r-&#62;s = Another Lisp string
a[0] = 0.
a[1] = 1.
a[2] = 2.
a[3] = 3.
a[4] = 4.
a[5] = 5.
a[6] = 6.
a[7] = 7.
a[8] = 8.
a[9] = 9.
#S(TEST-C-CALL::CFUNR :X 10 :S "A C string")
&#62;
$ rm -r base+cfun
</PRE
></TD
></TR
></TABLE
></P
><P
ALIGN="justify"
>Note that there is a memory leak here: The return value
<TT
CLASS="varname"
>r2</TT
> of <TT
CLASS="function"
>cfun()</TT
> is
<A
HREF="http://www.opengroup.org/onlinepubs/007904975/functions/malloc.html"
TARGET="_top"
><TT
CLASS="function"
>malloc</TT
></A
>ed but never <A
HREF="http://www.opengroup.org/onlinepubs/007904975/functions/free.html"
TARGET="_top"
><TT
CLASS="function"
>free</TT
></A
>d. Specifying

<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>&#13;(:return-type (c-ptr cfunr) :malloc-free)
</PRE
></TD
></TR
></TABLE
>

is not an alternative because this would also

<TT
CLASS="function"
>free(r2-&#62;x)</TT
> but <TT
CLASS="varname"
>r2-&#62;x</TT
> is a
pointer to static data.</P
></DIV
><DIV
CLASS="example"
><A
NAME="ex-call-in"
></A
><P
><B
>Example 30-7. Calling Lisp from <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
></B
></P
><P
ALIGN="justify"
>To sort an array of double-floats using the Lisp function <A
HREF="http://www.lisp.org/HyperSpec/Body/fun_sortcm_stable-sort.html"
TARGET="_top"
><TT
CLASS="function"
>SORT</TT
></A
>
 instead of the <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
> library function <A
HREF="http://www.opengroup.org/onlinepubs/007904975/functions/qsort.html"
TARGET="_top"
><TT
CLASS="function"
>qsort</TT
></A
>, one can use the
 following interface code <TT
CLASS="filename"
>sort1.c</TT
>.
 The main problem is to pass a variable-sized array.

<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>&#13;extern void lispsort_begin (int);
void* lispsort_function;
void lispsort_double (int n, double * array) {
    double * sorted_array;
    int i;
    lispsort_begin(n); /* store #'sort2 in lispsort_function */
    sorted_array = ((double * (*) (double *)) lispsort_function) (array);
    for (i = 0; i &#60; n; i++) array[i] = sorted_array[i];
    free(sorted_array);
}
</PRE
></TD
></TR
></TABLE
>

This is accompanied by <TT
CLASS="filename"
>sort2.lisp</TT
>:

<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>&#13;(<A
HREF="http://www.lisp.org/HyperSpec/Body/mac_defpackage.html"
TARGET="_top"
><TT
CLASS="function"
>DEFPACKAGE</TT
></A
> "FFI-TEST" (:use "LISP" "FFI"))
(<A
HREF="http://www.lisp.org/HyperSpec/Body/mac_in-package.html"
TARGET="_top"
><TT
CLASS="function"
>IN-PACKAGE</TT
></A
> "FFI-TEST")
(def-call-in lispsort_begin (:arguments (n int))
  (:return-type nil)
  (:language :stdc))
(def-c-var lispsort_function (:type c-pointer))
(defun lispsort_begin (n)
  (setf (cast lispsort_function
              `(c-function
                 (:arguments (v (c-ptr (c-array double-float ,n))))
                 (:return-type (c-ptr (c-array double-float ,n))
                               :malloc-free)))
        #'sort2))
(defun sort2 (v)
  (declare (type vector v))
  (sort v #'&#60;))
</PRE
></TD
></TR
></TABLE
>

To test this, use the following test file <TT
CLASS="filename"
>sorttest.lisp</TT
>:

<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>&#13;(def-call-out sort10
  (:name "lispsort_double")
  (:language :stdc)
  (:arguments (n int)
              (array (c-ptr (c-array double-float 10)) :in-out)))
</PRE
></TD
></TR
></TABLE
>

Now try

<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>&#13;$ clisp-link create-module-set sort sort2.c sorttest.c
$ cc -O -c sort1.c
$ cd sort
$ ln -s ../sort1.o sort1.o
</PRE
></TD
></TR
></TABLE
>

Add <TT
CLASS="filename"
>sort1.o</TT
> to <TT
CLASS="envar"
>NEW_LIBS</TT
>
and <TT
CLASS="envar"
>NEW_FILES</TT
> in <TT
CLASS="filename"
>link.sh</TT
>.
Create a file <TT
CLASS="filename"
>package.lisp</TT
> containing the
form <TT
CLASS="sexp"
>(<A
HREF="http://www.lisp.org/HyperSpec/Body/mac_defpackage.html"
TARGET="_top"
><TT
CLASS="function"
>DEFPACKAGE</TT
></A
> "FFI-TEST" (:use "LISP"
"FFI"))</TT
> and add <TT
CLASS="filename"
>package.lisp</TT
>
to <TT
CLASS="envar"
>TO_PRELOAD</TT
> in <TT
CLASS="filename"
>link.sh</TT
>.
Proceed:

<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>&#13;$ cd ..
$ base/lisp.run -M base/lispinit.mem -c sort2.lisp sorttest.lisp
$ clisp-link add-module-set sort base base+sort
$ base+sort/lisp.run -M base+sort/lispinit.mem -i sort2 sorttest
&#62; (sort10 10 '#(0.501d0 0.528d0 0.615d0 0.550d0 0.711d0
                0.523d0 0.585d0 0.670d0 0.271d0 0.063d0))
#(0.063d0 0.271d0 0.501d0 0.523d0 0.528d0 0.55d0 0.585d0 0.615d0 0.67d0 0.711d0)
$ rm -r base+sort
</PRE
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="example"
><A
NAME="dffi-gethostname"
></A
><P
><B
>Example 30-8. Variable size arguments:
  calling <A
HREF="http://www.opengroup.org/onlinepubs/007904975/functions/gethostname.html"
TARGET="_top"
><TT
CLASS="function"
>gethostname</TT
></A
> from <A
HREF="http://clisp.cons.org"
TARGET="_top"
><B
CLASS="command"
>CLISP</B
></A
></B
></P
><P
ALIGN="justify"
><DIV
CLASS="funcsynopsis"
><A
NAME="AEN19828"
></A
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><SPAN
CLASS="type"
>int</SPAN
> <B
CLASS="FSFUNC"
>gethostname</B
></CODE
>(<SPAN
CLASS="type"
>char*</SPAN
> <VAR
CLASS="PDPARAM"
>name</VAR
>, <SPAN
CLASS="type"
>size_t</SPAN
> <VAR
CLASS="PDPARAM"
>namelen</VAR
>);</CODE
></P
><P
></P
></DIV
>
 follows a typical pattern of <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
> "out"-parameter convention - it
 expects a pointer to a buffer it is going to fill.
 So you must view this parameter as either <TT
CLASS="constant"
>:OUT</TT
> or <TT
CLASS="constant"
>:IN-OUT</TT
>.
 Additionaly, one must tell the function the size of the buffer.
 Here <TT
CLASS="replaceable"
><I
>namelen</I
></TT
> is just an <TT
CLASS="constant"
>:IN</TT
> parameter.
 Sometimes this will be an <TT
CLASS="constant"
>:IN-OUT</TT
> parameter, returning the
 number of bytes actually filled in.</P
><P
ALIGN="justify"
>So <TT
CLASS="replaceable"
><I
>name</I
></TT
> is actually a pointer to an
 array of up to <TT
CLASS="replaceable"
><I
>namelen</I
></TT
> characters,
 regardless of what the poor <SPAN
CLASS="type"
>char*</SPAN
> <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
> prototype says,
 to be used like a <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
> <SPAN
CLASS="type"
>string</SPAN
> (0-termination).
 <A
HREF="http://www.UNIX-systems.org/online.html"
TARGET="_top"
><B
CLASS="emphasis"
>UNIX</B
></A
> specifies that "kost names are limited to HOST_NAME_MAX bytes",
 which is, of course, system dependent, but it appears that 256 is a
 common value.</P
><P
ALIGN="justify"
>In the present example, you can use allocation <TT
CLASS="constant"
>:ALLOCA</TT
>, like
 you would do in <A
HREF="http://www.eskimo.com/~scs/C-faq/top.html"
TARGET="_top"
><B
CLASS="command"
>C</B
></A
>: stack-allocate a temporary.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>&#13;(<A
HREF="dffi.html#def-c-call-out"
><TT
CLASS="function"
>FFI:DEF-C-CALL-OUT</TT
></A
> gethostname
  (:arguments (name (<A
HREF="dffi.html#c-ptr"
><SPAN
CLASS="type"
>FFI:C-PTR</SPAN
></A
> (<A
HREF="dffi.html#c-array-max"
><SPAN
CLASS="type"
>FFI:C-ARRAY-MAX</SPAN
></A
> ffi:char 256))
		    <TT
CLASS="constant"
>:OUT</TT
> <TT
CLASS="constant"
>:ALLOCA</TT
>)
	      (len ffi:int))
  (:return-type ffi:int))

(defun myhostname ()
  (multiple-value-bind (success name)
      ;; <TT
CLASS="constant"
>:OUT</TT
> and <TT
CLASS="constant"
>:IN-OUT</TT
> parameters are returned as multiple values
      (gethostname 256)
    (if (zerop success) name
	(error ...)))) ;; <A
HREF="http://www.opengroup.org/onlinepubs/007904975/functions/strerror.html"
TARGET="_top"
><TT
CLASS="function"
>strerror</TT
></A
>(<A
HREF="http://www.opengroup.org/onlinepubs/007904975/functions/errno.html"
TARGET="_top"
><TT
CLASS="varname"
>errno</TT
></A
>)

(defvar hostname (myhostname))
</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="section"
><H3
CLASS="section"
><A
NAME="dffi-ex-more"
></A
>30.3.9.1. More examples</H3
><P
ALIGN="justify"
>You can find more information and examples of the <A
HREF="http://clisp.cons.org"
TARGET="_top"
><B
CLASS="command"
>CLISP</B
></A
>
 <A
HREF="dffi.html"
><STRONG
CLASS="package"
><SPAN
CLASS="QUOTE"
>"FFI"</SPAN
></STRONG
></A
> in the following <TT
CLASS="email"
>&#60;<A
HREF="mailto:clisp-list@sf.net"
>clisp-list@sf.net</A
>&#62;</TT
> messages:
 <P
></P
><UL
><LI
><P
ALIGN="justify"
><A
HREF="http://article.gmane.org/gmane.lisp.clisp.general/7278"
TARGET="_top"
>"variable size values"</A
></P
></LI
><LI
><P
ALIGN="justify"
><A
HREF="http://article.gmane.org/gmane.lisp.clisp.general/6626"
TARGET="_top"
>"variable length arrays"</A
></P
></LI
></UL
>
</P
></DIV
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="modules.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="impnotes-top.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="affi.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Extensions-2.2. External Modules</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="platform.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Extensions-2.4. The Amiga Foreign Function Call Facility</TD
></TR
></TABLE
></DIV
><div
class="custom-footer"
><hr
width="100%"><table
width="100%"
><tr
><td
align="left"
><a
href="http://clisp.cons.org"
><img
src="clisp.png"
width="48"
height="48"
alt="[CLISP home]"></a
></td
><td
align="center"
><a
href="http://www.gnu.org"
><img
src="http://www.gnu.org/graphics/gnubanner.jpg"
width="468"
height="60"
alt="[Come and see what GNU creates for YOU]"></a
></td
><td
align="right"
><a
href="http://sourceforge.net"
><img
src="http://sourceforge.net/sflogo.php?group_id=1355&amp;type=2"
width="125"
height="37"
alt="[SourceForge]"></a
></td
></tr
></table
></div
></BODY
></HTML
>